<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>cly</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="cly">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="cly">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liangyu Chen">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="cly" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">cly</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-BUUCTF刷题记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:26:31.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">BUUCTF刷题记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>由于我还没有搞定网站上LateX的使用问题，公式根本打不出来，文中“易知”的部分可以去<a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_79140522/article/details/140601121">我的CSDN文章</a>上面看。<br>图片也没有搞定，只能去引用的其他人的博客里面去找。<br><a target="_blank" rel="noopener" href="https://buuoj.cn/challenges">刷题网址</a><br>一个密码学整理得非常好的<a target="_blank" rel="noopener" href="https://lazzzaro.github.io/">博客</a></p>
<h2 id="1-摩丝"><a href="#1-摩丝" class="headerlink" title="1. 摩丝"></a>1. 摩丝</h2><p>这道题非常简单，对照下面的摩丝表就能很快得到答案。需要特别注意的是，摩丝编码里面只有大写字母，没有小写字母。<br>（图片参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/acmdream/article/details/78329497?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172161266716800222835263%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=172161266716800222835263&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-78329497-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=%E6%91%A9%E4%B8%9D%E5%AF%86%E7%A0%81%E8%A7%84%E5%BE%8B&spm=1018.2226.3001.4187">摩斯密码对照表-CSDN博客</a>）</p>
<h2 id="2-MD5"><a href="#2-MD5" class="headerlink" title="2. MD5"></a>2. MD5</h2><p>使用解密MD5的网站可以轻松解决。<br>解密MD5的相关<a target="_blank" rel="noopener" href="https://www.cmd5.com/">网站</a><br>一个包含了挺多MD5解密的工具集：<a target="_blank" rel="noopener" href="http://www.ctftools.com/">CTF资源库|CTF工具下载|CTF工具包|CTF工具集合</a></p>
<h2 id="3-BJDCTF-2nd-cat-flag"><a href="#3-BJDCTF-2nd-cat-flag" class="headerlink" title="3. [BJDCTF 2nd]cat_flag"></a>3. [BJDCTF 2nd]cat_flag</h2><p>打开附件是一个动图，动图由两种小图片组成，每一行有八张图片，很明显是用两种不同的图片来代替0、1。把两种情况都考虑一遍，再用ASCII码表进行解码，即可得到结果。<br>这里记录一下ASCII码表。<br>（图片参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53030983/article/details/121687624?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172155958516800225532531%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172155958516800225532531&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121687624-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=ascll%E7%A0%81%E8%A1%A8&spm=1018.2226.3001.4187">字母数字-ASCII码表（最详细，最直观）-CSDN博客</a>）</p>
<h2 id="4-GKCTF2020-小学生的密码学"><a href="#4-GKCTF2020-小学生的密码学" class="headerlink" title="4. [GKCTF2020]小学生的密码学"></a>4. [GKCTF2020]小学生的密码学</h2><p>题目如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e(x)=11x+6(mod26)</span><br><span class="line">密文：welcylk</span><br><span class="line">（flag为base64形式）</span><br></pre></td></tr></table></figure>
<p>这是一个简单的仿射密码。<br>易知，在sagemath中可编写如下代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;welcylk&#x27;</span><br><span class="line">d=pow(11,-1,26)</span><br><span class="line">s=&#x27;&#x27;</span><br><span class="line">for i in a:</span><br><span class="line">    aa=ord(i)-97</span><br><span class="line">    ab=(aa-6)*d</span><br><span class="line">    ac=ab%26</span><br><span class="line">    ad=int(ac)+97</span><br><span class="line">    print(hex(ad))</span><br><span class="line">    s=s+chr(ad)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>再把结果进行base64编码，然后包上flag{}即可得到答案。</p>
<h2 id="5-NewStarCTF-2023-公开赛道-babyrsa"><a href="#5-NewStarCTF-2023-公开赛道-babyrsa" class="headerlink" title="5. [NewStarCTF 2023 公开赛道]babyrsa"></a>5. [NewStarCTF 2023 公开赛道]babyrsa</h2><p>这个rsa中的n是由多个小质数组成的，使用素因数分解的网站可以轻松进行分解。<br><a target="_blank" rel="noopener" href="http://factordb.com/">网站</a><br>分解后，需要计算phi。这里的phi需要将所有的素数减一后相乘。</p>
<h2 id="6-Dest0g3-520迎新赛-babyRSA"><a href="#6-Dest0g3-520迎新赛-babyRSA" class="headerlink" title="6. [Dest0g3 520迎新赛]babyRSA"></a>6. [Dest0g3 520迎新赛]babyRSA</h2><p>这道题中p和q存在next_prime的关系，所以两个数的差较小，可以遍历这个差值找到答案。我们先对n开平方根，此时得到的结果x应该在p、q之间，且与p、q的差值不大。不断遍历x、x+1、x+2···，判断他们是否可以整除n，即可找到p、q的值。<br>sagemath中的脚本如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n=27272410937497615429184017335437367466288981498585803398561456300019447702001403165885200936510173980380489828828523983388730026101865884520679872671569532101708469344562155718974222196684544003071765625134489632331414011555536130289106822732544904502428727133498239161324625698270381715640332111381465813621908465311076678337695819124178638737015840941223342176563458181918865641701282965455705790456658431641632470787689389714643528968037519265144919465402561959014798324908010947632834281698638848683632113623788303921939908168450492197671761167009855312820364427648296494571794298105543758141065915257674305081267</span><br><span class="line">c=14181751948841206148995320731138166924841307246014981115736748934451763670304308496261846056687977917728671991049712129745906089287169170294259856601300717330153987080212591008738712344004443623518040786009771108879196701679833782022875324499201475522241396314392429412747392203809125245393462952461525539673218721341853515099201642769577031724762640317081252046606564108211626446676911167979492329012381654087618979631924439276786566078856385835786995011067720124277812004808431347148593882791476391944410064371926611180496847010107167486521927340045188960373155894717498700488982910217850877130989318706580155251854</span><br><span class="line">for i in range(1000000000):</span><br><span class="line">    a=n.nth_root(2, truncate_mode=True)</span><br><span class="line">    a=int(a[0])+i</span><br><span class="line">    if n%a==0:</span><br><span class="line">        print(a)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<h2 id="7-NewStarCTF-公开赛赛道-caeser"><a href="#7-NewStarCTF-公开赛赛道-caeser" class="headerlink" title="7. [NewStarCTF 公开赛赛道]caeser"></a>7. [NewStarCTF 公开赛赛道]caeser</h2><p>这道题的密文为<br><code>synt&#123;uvfgbevpny_pvcure_vf_ihyarenoyr&#125;</code><br>根据经验判断，synt的明文应该是flag，计算他们每个字母的ASCII码之间的差，发现相等。对其他字母也减去相同的差值，即可得到结果。</p>
<h2 id="8-NewStarCTF-公开赛赛道-吉奥万·巴蒂斯塔·贝拉索先生的密码"><a href="#8-NewStarCTF-公开赛赛道-吉奥万·巴蒂斯塔·贝拉索先生的密码" class="headerlink" title="8. [NewStarCTF 公开赛赛道]吉奥万·巴蒂斯塔·贝拉索先生的密码"></a>8. [NewStarCTF 公开赛赛道]吉奥万·巴蒂斯塔·贝拉索先生的密码</h2><p>题目为  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pqcq&#123;gteygpttmj_kc_zuokwv_kqb_gtofmssi_mnrrjt&#125;</span><br><span class="line"></span><br><span class="line">Hint: key length is 3</span><br></pre></td></tr></table></figure>
<p>上面一行是密文，下面一行是提示。<br>这是一个维吉尼亚密码，key的长度为3表示上面的字母每3个为一组，每组的解密方式都是相同的。<br>猜测前面四个字母为flag，即可知道分组中每一个字母需要减去的数值，编写C语言代码可以得到结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	char *s=&quot;pqcqgteygpttmjkczuokwvkqbgtofmssimnrrjt&quot;;</span><br><span class="line">	for(int j=0;j&lt;strlen(s);j++)&#123;</span><br><span class="line">		int m=(s[j]-97)%26+97;</span><br><span class="line">		while(m&lt;97)&#123;</span><br><span class="line">			m+=26;</span><br><span class="line">		&#125;</span><br><span class="line">		if(j%3==0)&#123;</span><br><span class="line">			m=m-10;</span><br><span class="line">			while(m&lt;97)&#123;</span><br><span class="line">				m+=26;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%c&quot;,m);</span><br><span class="line">		&#125;else if(j%3==1)&#123;</span><br><span class="line">			m=m-5;</span><br><span class="line">			while(m&lt;97)&#123;</span><br><span class="line">				m+=26;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%c&quot;,m);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			m=m-2;</span><br><span class="line">			while(m&lt;97)&#123;</span><br><span class="line">				m+=26;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%c&quot;,m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-NewStarCTF-2023-公开赛道-不止一个pi"><a href="#9-NewStarCTF-2023-公开赛道-不止一个pi" class="headerlink" title="9. [NewStarCTF 2023 公开赛道]不止一个pi"></a>9. [NewStarCTF 2023 公开赛道]不止一个pi</h2><p>这道题目中p、q均已知，主要的问题在于计算phi的值。<br>这里的n是p的三次方乘以q的二次方，而欧拉函数中phi的定义是小于n且与n互质的数的个数。<br>首先考虑<code>phi(p*q)</code>，我们知道是<code>(p-1)*(q-1)</code>。因此在1到<code>p*q</code>中有<code>(p-1)*(q-1)</code>个数与<code>p*q</code>互质。由于n中只有p、q这两个质数，所以在<code>1</code>到<code>p*q</code>中也正好有<code>(p-1)*(q-1)</code>个数与n互质。<br>由剩余系的概念可以知道在<code>p*q+1</code>到<code>2*p*q</code>中也正好有<code>(p-1)*(q-1)</code>个数与n互质，即每<code>p*q</code>个数中有<code>(p-1)*(q-1)</code>个数与n互质。而n中总共有<code>p*p*q</code>个<code>p*q</code>，所以<code>phi(n)</code>的值就是<code>p*p*q*(p-1)*(q-1)</code>。<br>使用该phi计算d的值，再计算明文，就能得到结果。</p>
<h2 id="10-一眼就解密"><a href="#10-一眼就解密" class="headerlink" title="10. 一眼就解密"></a>10. 一眼就解密</h2><p>这道题就是一道base64的解密题，这里记录一个解密的在线网站<br><a target="_blank" rel="noopener" href="https://base64.us/">Base64 在线编码解码 | Base64 加密解密 - Base64.us</a></p>
<h2 id="11-NewStarCTF-2023-公开赛道-滴啤"><a href="#11-NewStarCTF-2023-公开赛道-滴啤" class="headerlink" title="11. [NewStarCTF 2023 公开赛道]滴啤"></a>11. [NewStarCTF 2023 公开赛道]滴啤</h2><p>这道rsa的题目中给了dp、e、n和c。<br>易知，我们可以尝试计算出dp*e-1的值，再对其进行分解，以尝试获取到p-1的值。<br>这一题中，分解后可知该数共有8个素因数，其因数的总数量并不多，完全可以进行遍历。由于p的位数约为512位，而素因数有一个近400位的素数，所以它一定是p-1的一个因数（反证法易证）。那么我们遍历的数量就可以进一步减少了。<br>使用sagemath进行遍历的代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p2=2*13576168482904074972916434606484064894094750779290370955123911937153145555527439626414947690638030717530975726269496353</span><br><span class="line">m=[3,3,3,7,251,133201,52499805387917,2237058624000923]</span><br><span class="line">n=93172788492926438327710592564562854206438712390394636149385608321800134934361353794206624031396988124455847768883785503795521389178814791213054124361007887496351504099772757164211666778414800698976335767027868761735533195880182982358937211282541379697714874313863354097646233575265223978310932841461535936931</span><br><span class="line">for i in range(256):</span><br><span class="line">    x=bin(i)[2:].zfill(8)</span><br><span class="line">    p=p2</span><br><span class="line">    for j in range(len(x)):</span><br><span class="line">        if int(x[j])==1:</span><br><span class="line">            p=p*int(x[j])*int(m[j])</span><br><span class="line">    p=p+1</span><br><span class="line">    if n%p==0:</span><br><span class="line">        print(p)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<h2 id="12-NewStarCTF-2023-公开赛道-babyencoding"><a href="#12-NewStarCTF-2023-公开赛道-babyencoding" class="headerlink" title="12. [NewStarCTF 2023 公开赛道]babyencoding"></a>12. [NewStarCTF 2023 公开赛道]babyencoding</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">part 1 of flag: ZmxhZ3tkYXp6bGluZ19lbmNvZGluZyM0ZTBhZDQ=</span><br><span class="line">part 2 of flag: MYYGGYJQHBSDCZJRMQYGMMJQMMYGGN3BMZSTIMRSMZSWCNY=</span><br><span class="line">part 3 of flag: =8S4U,3DR8SDY,C`S-F5F-C(S,S&lt;R-C`Q9F8S87T`</span><br></pre></td></tr></table></figure>
<p>这道题就是三种不同的编码方式。<br>第一部分中有大小写字母和数字，最后还有一个等号，是base64编码，使用网站可以解决（网站见“一眼就解密”模块）。<br>第二部分只有大写字母和数字，是base32编码，我用sagemath写了个脚本进行解码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;MYYGGYJQHBSDCZJRMQYGMMJQMMYGGN3BMZSTIMRSMZSWCNY&#x27;</span><br><span class="line">c=[]</span><br><span class="line">for i in a:</span><br><span class="line">    m=ord(i)</span><br><span class="line">    if m&gt;0x40:</span><br><span class="line">        c.append(int(m-ord(&#x27;A&#x27;)))</span><br><span class="line">    else:</span><br><span class="line">        c.append(int(m-ord(&#x27;2&#x27;))+26)</span><br><span class="line">s=&#x27;&#x27;</span><br><span class="line">for i in c:</span><br><span class="line">    a=bin(i)[2:].zfill(5)</span><br><span class="line">    s=s+a</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>这个脚本得到的结果为二进制的结果，最后需要进行补零，使其位数为8的倍数。<br>第三部分的编码方式为UUencode编码，可以利用在线网站进行解密。<br>可使用网站：<a target="_blank" rel="noopener" href="https://ctf.bugku.com/tools">在线工具 - Bugku CTF</a></p>
<h2 id="13-NewStarCTF-2023-公开赛道-babyxor"><a href="#13-NewStarCTF-2023-公开赛道-babyxor" class="headerlink" title="13. [NewStarCTF 2023 公开赛道]babyxor"></a>13. [NewStarCTF 2023 公开赛道]babyxor</h2><p>这道题目把flag中的每一个字符与一个未知的key异或之后进行了输出，因此我们需要解出这个key的值。直接猜测flag中的前四个字符为“flag”，把这四个字符与已知的输出值的前三十二位进行一次异或，发现得到的结果是重复的0x8f，因此key的值就是0x8f。</p>
<h2 id="14-NewStarCTF-公开赛赛道-eazyxor"><a href="#14-NewStarCTF-公开赛赛道-eazyxor" class="headerlink" title="14. [NewStarCTF 公开赛赛道]eazyxor"></a>14. [NewStarCTF 公开赛赛道]eazyxor</h2><p>这道题目和13里面一模一样，这里就把sagemath计算key的脚本放一下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=0x9b919c9a</span><br><span class="line">b=0x666c6167</span><br><span class="line">def xor(p,q):</span><br><span class="line">    p=int(p)</span><br><span class="line">    q=int(q)</span><br><span class="line">    return p&amp;(~q)|(~p)&amp;q</span><br><span class="line">c=xor(a,b)</span><br><span class="line">print(hex(c))</span><br></pre></td></tr></table></figure>
<p>（最近发现在sagemath中^^可以表示异或，所以其实并不需要写一个异或的函数）</p>
<h2 id="15-NewStarCTF-2023-公开赛道-Affine"><a href="#15-NewStarCTF-2023-公开赛道-Affine" class="headerlink" title="15. [NewStarCTF 2023 公开赛道]Affine"></a>15. [NewStarCTF 2023 公开赛道]Affine</h2><p>这也是一道仿射变换的题目，需要求出key的值（key是一个包含两个元素的列表）。<br>易知，可以用sagemath写出解密的代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">f1=0x66</span><br><span class="line">f2=0x61</span><br><span class="line">b1=0xdd</span><br><span class="line">b2=0x88</span><br><span class="line">b=b1-b2</span><br><span class="line">f=f1-f2</span><br><span class="line">x=pow(f,-1,256)</span><br><span class="line">a0=(b*x)%256</span><br><span class="line">a1=(b1-f1*a0)%256</span><br><span class="line">n=pow(a0,-1,256)</span><br><span class="line">h=&#x27;dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064&#x27;</span><br><span class="line">c=&#x27;&#x27;</span><br><span class="line">for i in range(len(h)//2):</span><br><span class="line">    x=&#x27;0x&#x27;+h[2*i]+h[2*i+1]</span><br><span class="line">    b=int(x,16)</span><br><span class="line">    m=((b-a1)*n)%256</span><br><span class="line">    c=c+chr(m)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<p>在“flag”中使用差值计算出f时，结果可能不会和256互质，比如“f”和“l”这两个字符，所以我在选择明文时选择了“f”和“a”这两个字符。</p>
<h2 id="16-NewStarCTF-2023-公开赛道-halfcandecode"><a href="#16-NewStarCTF-2023-公开赛道-halfcandecode" class="headerlink" title="16. [NewStarCTF 2023 公开赛道]halfcandecode"></a>16. [NewStarCTF 2023 公开赛道]halfcandecode</h2><p>这道题是上面的第二题和第六题的结合体，需要用到rsa和MD5。<br>rsa的部分也可以使用第五题中的网站进行分解。需要注意的是出题人在前半部分flag的后面加入了一些乱码，在解密的时候需要删除。MD5的部分则只要使用第六题的网站就能解决。其中有些MD5的值需要充钱获取，可以使用网站<a target="_blank" rel="noopener" href="https://www.somd5.com/">MD5免费在线解密破解_MD5在线加密-SOMD5破解</a>。</p>
<h2 id="17-NewStarCTF-2023-公开赛道-Rotate-Xor"><a href="#17-NewStarCTF-2023-公开赛道-Rotate-Xor" class="headerlink" title="17. [NewStarCTF 2023 公开赛道]Rotate Xor"></a>17. [NewStarCTF 2023 公开赛道]Rotate Xor</h2><p>易知，用sagemath编写下面的代码得到k1的值：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enc_k1 = 7318833940520128665</span><br><span class="line">k2 = 9982833494309156947</span><br><span class="line">key=enc_k1</span><br><span class="line">def round_rotate_right(num, step):</span><br><span class="line">    return ((num) &gt;&gt; step | num &lt;&lt; (64-step))&amp;0xffffffffffffffff</span><br><span class="line">for _ in range(12):</span><br><span class="line">    key=xor(key,k2)</span><br><span class="line">    key=round_rotate_right(key,3)</span><br><span class="line">print(hex(key))</span><br></pre></td></tr></table></figure>
<p>代码中的xor函数在第十四题的脚本中进行了定义。<br>得到k1后，发现k1的长度与给出的密文ciphertext的长度是不一致的，因此需要知道题目中加密用到的函数xor的用法。这个是从pwn库中引入的函数，我猜测是像分组密码一样分组进行异或，就用最前面的四个字符尝试了一下，发现得到的确实是“flag”。所以按照分组密码的加密方式对密文进行了异或，就得到了答案。</p>
<h2 id="18-NewStarCTF-2023-公开赛道-babyNTRU"><a href="#18-NewStarCTF-2023-公开赛道-babyNTRU" class="headerlink" title="18. [NewStarCTF 2023 公开赛道]babyNTRU"></a>18. [NewStarCTF 2023 公开赛道]babyNTRU</h2><p>这是一道格密码的题目，易知，写出的sagemath代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h=8916452722821418463248726825721257021744194286874706915832444631771596616116491775091473142798867278598586482678387668986764461265131119164500473719939894343163496325556340181429675937641495981353857724627081847304246987074303722642172988864138967404024201246050387152854001746763104417773214408906879366958729744259612777257542351501592019483745621824894790096639205771421560295175633152877667720038396154571697861326821483170835238092879747297506606983322890706220824261581533324824858599082611886026668788577757970984892292609271082176311433507931993672945925883985629311514143607457603297458439759594085898425992</span><br><span class="line">q=31985842636498685945330905726539498901443694955736332073639744466389039373143618920511122288844282849407290205804991634167816417468703459229138891348115191921395278336695684210437130681337971686008048054340499654721317721241239990701099685207253476642931586563363638141636011941268962999641130263828151538489139254625099330199557503153680089387538863574480134898211311252227463870838947777479309928195791241005127445821671684607237706849308372923372795573732000365072815112119533702614620325238183899266147682193892866330678076925199674554569018103164228278742151778832319406135513140669049734660019551179692615505961</span><br><span class="line">e=20041713613876382007969284056698149007154248857420752520496829246324512197188211029665990713599667984019715503486507126224558092176392282486689347953069815123212779090783909545244160318938357529307482025697769394114967028564546355310883670462197528011181768588878447856875173263800885048676190978206851268887445527785387532167370943745180538168965461612097037041570912365648125449804109299630958840398397721916860876687808474004391843869813396858468730877627733234832744328768443830669469345926766882446378765847334421595034470639171397587395341977453536859946410431252287203312913117023084978959318406160721042580688</span><br><span class="line">mat=[[e,0,1],[h,1,0],[q,0,0]]</span><br><span class="line">M = Matrix(QQ,mat)</span><br><span class="line">lll=M.LLL()</span><br><span class="line">print((lll[0]))</span><br></pre></td></tr></table></figure>
<p>其中打印出来的结果即为上面的公式中等号右边的向量。</p>
<h2 id="19-GKCTF2020-babycrypto"><a href="#19-GKCTF2020-babycrypto" class="headerlink" title="19. [GKCTF2020]babycrypto"></a>19. [GKCTF2020]babycrypto</h2><p>这道题中的n可以直接使用第五题中的网站进行分解。</p>
<h2 id="20-NewStarCTF-2023-公开赛道-Smart"><a href="#20-NewStarCTF-2023-公开赛道-Smart" class="headerlink" title="20. [NewStarCTF 2023 公开赛道]Smart"></a>20. [NewStarCTF 2023 公开赛道]Smart</h2><p>这是一道ecc的题目，根据提示可以使用smart attack的方法解题。使用sagemath可以编写出下面的代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">p = 75206427479775622966537995406541077245842499523456803092204668034148875719001</span><br><span class="line">a = 40399280641537685263236367744605671534251002649301968428998107181223348036480</span><br><span class="line">b = 34830673418515139976377184302022321848201537906033092355749226925568830384464</span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line">P=E(63199291976729017585116731422181573663076311513240158412108878460234764025898,11977959928854309700611217102917186587242105343137383979364679606977824228558)</span><br><span class="line">Q=E(75017275378438543246214954287362349176908042127439117734318700769768512624429,39521483276009738115474714281626894361123804837783117725653243818498259351984)</span><br><span class="line">def SmartAttack(P,Q,p):</span><br><span class="line">    E = P.curve()</span><br><span class="line">    Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ])</span><br><span class="line">    P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True)</span><br><span class="line">    for P_Qp in P_Qps:</span><br><span class="line">        if GF(p)(P_Qp.xy()[1]) == P.xy()[1]:</span><br><span class="line">            break</span><br><span class="line">    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True)</span><br><span class="line">    for Q_Qp in Q_Qps:</span><br><span class="line">        if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]:</span><br><span class="line">            break</span><br><span class="line">    p_times_P = p*P_Qp</span><br><span class="line">    p_times_Q = p*Q_Qp</span><br><span class="line">    x_P,y_P = p_times_P.xy()</span><br><span class="line">    x_Q,y_Q = p_times_Q.xy()</span><br><span class="line">    phi_P = -(x_P/y_P)</span><br><span class="line">    phi_Q = -(x_Q/y_Q)</span><br><span class="line">    k = phi_Q/phi_P</span><br><span class="line">    return ZZ(k)</span><br><span class="line">r = SmartAttack(P, Q, p)</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure>
<h2 id="21-V-N2020-公开赛-Backtrace"><a href="#21-V-N2020-公开赛-Backtrace" class="headerlink" title="21. [V&amp;N2020 公开赛]Backtrace"></a>21. [V&amp;N2020 公开赛]Backtrace</h2><p>这是一道向前还原梅森旋转算法产生的随机数的题目，可以使用python3中已有的库中的函数进行解密，脚本如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from extend_mt19937_predictor import ExtendMT19937Predictor</span><br><span class="line">predictor = ExtendMT19937Predictor()</span><br><span class="line">x=[1954915070, 880079313, 360906530, 1379349539, 2990290602, 2779090715, 1195886637, 26260733, 1583365168, 3665368407, 32035604, 23154243, 4175855420, 4087729539, 4061778341, 1842490363, 24026296, 506531036, 3305517750, 2480717543, 3912881681, 2674873504, 3352869450, 3592419601, 3036323492, 1082383946, 3598180449, 547795339, 549590551, 3028169916, 2073824705, 1647033805, 1120414536, 3923037909, 3779751646, 2143420925, 3908526958, 3918342792, 3262098248, 3804166870, 1736455411, 2417662325, 3135605338, 428676667, 3664109984, 2807365630, 592564266, 1511929376, 3720241883, 3519131811, 88062728, 2452008344, 1376675709, 666109304, 4110417201, 4220702851, 3778634814, 4211738848, 715753516, 2658852621, 2979894716, 1247212269, 4178194405, 1781101726, 1041419594, 1709310125, 3813614389, 458927554, 3764695336, 2441752341, 1253881549, 1225143052, 3557368845, 3838600385, 704097569, 1795077589, 1307245977, 1717115299, 983409487, 2129778243, 3432359775, 1630272089, 1044229449, 1934797629, 256992360, 739187055, 2003823253, 2520758703, 4188045315, 1831601825, 1613890879, 43212525, 286036422, 730199546, 2111917986, 2296406771, 1523494866, 22453673, 1713781269, 289582587, 1190283387, 215790012, 3341532120, 4143468851, 3911058947, 1744160183, 1737482991, 995300206, 1209025742, 2548392860, 2112397256, 2328723112, 3252904928, 2986221228, 920151702, 2869410691, 297356863, 1113160659, 1723226249, 91041567, 1364664100, 1603980497, 1950077086, 2463918675, 1270243131, 2690292580, 1422349327, 862261952, 967425382, 2141373124, 784240543, 3431833360, 490754262, 3848551199, 3374708506, 1730158500, 1679948052, 1037254337, 1542986195, 3179769778, 525752391, 2138533768, 4060094504, 3749351453, 1653628056, 3891244202, 587949751, 2117666819, 3989217878, 236634714, 347834593, 36437255, 857428838, 802901512, 2150725842, 1293111161, 149116333, 1195588424, 2803507599, 1721551167, 3936542960, 3957883800, 126595404, 871451152, 565527716, 1622812264, 2809311587, 3016835340, 162902761, 4206750381, 3921119290, 1504723782, 3293690462, 3083506005, 811746919, 3455687374, 767562328, 3777952933, 2172820246, 2605716515, 1756246148, 2243128034, 1344314147, 3763482539, 2562146979, 3163206461, 3618311150, 1189035477, 7231879, 815006324, 195187971, 1578170963, 1078365572, 463220548, 92395730, 2138595439, 1322999823, 2469535746, 2749391749, 3433099223, 3983509306, 2111542870, 3745476971, 919481220, 1230712391, 3811227914, 1736577469, 2419466842, 1541026951, 398886450, 1510256083, 3548576351, 1983859038, 938962757, 172522539, 1019282319, 332128756, 3299336175, 2841132609, 2197477198, 3371426587, 1442166578, 3238850747, 1747647226, 2283411662, 1204012944, 3295272849, 1586724848, 4022995561, 3742366393, 79843478, 2109666146, 2406199134, 420281144, 1098025843, 519159390, 536903419, 2387574872, 585556144, 4037282670, 1816756967, 3987753062, 1495823125, 1010457539, 720442860, 8816820, 1812416478, 3356964625, 158012176, 902760599, 1749660162, 4160594328, 393212714, 877871013, 3616848204, 4126377209, 4259811533, 1989917399, 582786867, 1093424901, 1333179279, 1800875923, 1598085790, 627659277, 32688263, 2222145572, 938619663, 1467384991, 2777852620, 4233202126, 295416244, 3515893229, 572401093, 2526938242, 3851968999, 3599541582, 91522073, 1825233519, 2339315265, 4123218487, 2650729621, 287304953, 1423724344, 2908364142, 2748769808, 3418694754, 3917094690, 2646486860, 2858627000, 3305171165, 3401244148, 2180778517, 1737578689, 1322497258, 4144511518, 1856725795, 1477318062, 911248289, 1535195390, 3144994767, 4101205532, 3808591560, 2213985378, 3252595633, 2337367507, 534460335, 2441670955, 1990989375, 3808438725, 3804201721, 3999376545, 1014481854, 2090372701, 2927739146, 1300032996, 534772267, 3335311855, 664080148, 3129094809, 1075386087, 3651483413, 3363859879, 3226823199, 2964465151, 3285786367, 2581149182, 262038551, 2762741963, 922363707, 1260642832, 1183500610, 2803108134, 3592591385, 1484954269, 161632434, 3860482129, 3556119993, 1784107097, 1861391286, 3891693742, 1469562815, 4052616817, 1735123567, 3981493161, 1172433134, 4142248853, 1586222290, 3539037789, 1427799338, 1876694928, 1200583260, 1752440053, 291416352, 2106928780, 936954012, 197470641, 2337076377, 1421119809, 3135686533, 398635959, 4172800048, 399974723, 287928291, 529512170, 1921498685, 567654083, 1812953083, 4068864497, 2881211664, 2429816180, 4084286231, 1928525086, 3886022768, 1443924813, 1820391016, 3624477251, 1452182198, 3501771914, 3307175554, 1233333926, 4242916900, 1054132061, 1725357747, 4125133480, 2860075310, 3091839411, 3820381997, 1335282777, 2927671741, 2241788945, 3488880264, 2095731302, 1214404049, 592041371, 3490153501, 238412730, 85745765, 1498653208, 288707861, 2868112869, 491758034, 375898933, 529291211, 1526086068, 1434399655, 758215890, 1276881381, 3266726291, 3413372766, 3488548535, 145011592, 45063434, 3505575389, 1780705822, 2662969703, 856437165, 3634545960, 2660427148, 977850868, 1582014613, 4189751436, 866116713, 1216606975, 420500706, 2031559891, 1026985902, 3713148233, 494872740, 590852345, 1318692699, 1051590564, 365025448, 210057222, 4081233470, 836354250, 2395488189, 3089620058, 3371189485, 2492384566, 317404020, 3448768638, 1914822123, 2007144480, 3375740426, 4089530814, 1711142699, 1845862399, 2063343799, 3364295943, 3659690944, 546211494, 1414275727, 3044491383, 3050919928, 3390640243, 3843994607, 4283790197, 1589762674, 2433218003, 3728021067, 1131986129, 2737833357, 2800289380, 2753380618, 900710707, 4131195838, 2668161437, 940253312, 4137815270, 939482424, 1748091577, 3546489510, 3421396386, 4148510311, 4165939267, 726262463, 3050178325, 3177146914, 3563060942, 1534352901, 3355774700, 3917022484, 2589474555, 3331795641, 1102689414, 3183908672, 1002812809, 152821999, 2292133358, 1383462496, 1723940974, 1109447662, 3735817236, 2653647203, 4026819614, 1197259783, 2243347947, 4231464616, 2510151911, 4222963505, 1139252638, 756514223, 3417745074, 1468496068, 3161226317, 1246424725, 1872920987, 2647633430, 3258968525, 253034280, 1645087047, 3247041431, 1054772676, 379436873, 2600620229, 2594042244, 661729386, 1665438570, 1017686809, 233096083, 845378242, 3372582854, 410404381, 2007910443, 4292394895, 3237528904, 3176696608, 3307483127, 1197245101, 162556298, 2316117728, 1197610943, 2268702243, 3342707155, 3853282575, 916356664, 679322020, 3607041524, 437255662, 1779501694, 2192606690, 3849753853, 2382746933, 3266572424, 1897113113, 3929458586, 2295574218, 3398667663, 489651240, 554749675, 2685580250, 271948130, 3301333969, 2402822376, 2006322914, 3300613934, 2720365129, 1219841771, 253738666, 4062523722, 908057314, 734682735, 3993608743, 2005954106, 4196754468, 2180968904, 2927088293, 3201719969, 3258216746, 1697012102, 451497250, 4140321978, 1626314925, 2634645740, 2650768687, 4037717892, 3530817306, 3154301628, 607258212, 1138057824, 1483931056, 1779526200, 772778910, 3269411312, 2168622217, 3392463299, 2129731229, 663170712, 3481534219, 3813779502, 4003014679, 1417316990, 3758399028, 3050577451, 4287031625, 4219536484, 3110762846, 3162149172, 2925735942, 3222005405, 3901793171, 2438213679, 2761390133, 2868086632, 2262419687, 2548717542, 662411455, 2628823526, 1947247956, 192432795, 356145859, 1388455292, 1337879771, 1318475009, 4194024566, 3055182968, 3818161981, 4122245354, 1163215145, 4064532043, 1427071812, 3338509721, 996878503, 4035314277, 4009039326, 916055062, 3817247526, 1111659075, 2245077089, 1027546064, 3342483659, 1793234141, 1571978271, 1560889567, 3201761295, 2525084128, 1111852520, 147467714, 3308281891, 2593100275, 1890216029, 2245520263, 3905179223, 4166586105, 4058069805, 2234254266, 897808812, 1276352683, 4089183900, 1496670572, 2979089043, 1110628736, 3320051082, 3285541627, 4026820048, 414845486, 2742275697, 2611076257, 2183923292, 715603118, 3655611426, 1042307613, 1538032337, 3770267700, 2701884650, 807662565, 1412021992, 2190384229, 636193740, 2262474952, 1037800098, 2251081302, 2110190277, 1818325893, 357637012, 3220347372, 3779111771, 2794951662, 2053531638, 3865719745, 1117551032, 2005076639, 3052789596, 1850346070, 3250668743, 3748374363, 3366024365, 1797731176, 4167453426, 3273801260, 270498944, 3409183492, 2435803649, 4214667811, 3331238798, 2204118424, 124311085, 821069678, 402529460, 4241047514, 3597966193, 2484307360, 745429577, 1575021475, 2880532249, 1653073618, 2042789973, 1988689809, 2986312451, 998861281, 3049071914, 3105090905, 1948439372, 1812644387, 2463127929, 4111481103, 986806020, 1163777124, 2780762085, 2078725375, 2407568318, 3342714967, 2772408458, 490512106, 143570762, 1232716574, 519717220, 158618961, 1436523816, 4216701765, 307191458, 2912138910, 3468252635, 386069354, 1634782909, 392302934, 781725611, 3497023560, 4225924396, 1795951064, 3928854990, 1539311975, 3391120265, 232461937, 4184782267, 1731411767, 1647711068, 2103390822, 3545452835, 3898032707, 2174552994, 1311574900, 822414312, 1839460614, 1762983458, 2140522204, 417114171, 2942594202, 3153277613, 706508900, 1240369844, 2262617676, 2812407518, 1840197328, 1824634385, 859165172, 1576784364, 585466601, 1765607687, 3423031247, 1284381057, 3382474784, 3123254074, 2194861604, 495637126, 2802357617, 1226312598, 1818564904, 2754819901, 3465896582, 414214415, 1786854851, 3480143070, 1969087474, 2384690047, 764711574, 888969866, 291549264, 1623430983, 1065342949, 3771290713, 2607894650, 2849509696, 633784811, 592845780, 3632194205, 889199132, 4102077198, 29170934, 34456705, 2613055456, 1078880049, 1106268704, 22020620, 2586845047, 2925005739, 1854339682, 1649915319, 4071303129, 4140750565, 897249960, 1279599439, 1549858622, 2530236320, 357028938, 187680170, 2825532344, 3474432045, 1459157318, 1078630130, 522441272, 1021727782, 756127542, 670068161, 1933389429, 2126666549, 3233405034, 691338491, 617019618, 1572960014, 2476894878, 3114330689, 190756003, 343951393, 254882512, 3232970324, 1278199314, 136867483, 1288546656, 3526700531, 2819009094, 3204612611, 1139498748, 3875800906, 255305389, 2504064025, 3125108091, 2176350989, 2469637779, 3339575355, 2999412374, 1282126909, 1551339993, 3573997525, 3812552026, 2137007302, 3302434775, 1777310304, 2053104074, 2328784509, 2188979055, 1553054099, 857550765, 3714986904, 21124773, 1651956692, 220434238, 483698922, 1770276048, 3987677675, 2078271890, 4127930299, 913495199, 1552004068, 318877141, 3540501698, 1999579835, 935784539, 390615388, 2903539749, 3837464977, 3922761762, 108363706, 767261731, 592768246, 100601999, 767766613, 1170959252, 723154566, 2277226093, 1249730541, 4207253124, 3412009687, 2427450601, 3312907551, 1823542002, 2660960835, 3032107443, 3010173489, 3100247405, 1939956123, 630159399, 2588902313, 2901045261, 3788987361, 802990870, 333237497, 1240204630, 2845468633, 3360840386, 3763275014, 2632404055, 3815462044, 3818227716, 1049832368, 54028478, 758732492, 1815724078, 1246513687, 2374051260, 807659196, 3751209486, 3409043148, 559342443, 2430700654, 398612276, 241887832, 1939697736, 2288135888, 655726394, 1451329969, 1119873489, 799074425, 2253637924, 2053706296, 1548769628, 3867902836, 1247111501, 1004835651, 2850968664, 653021090, 1292848338, 154967348, 4194736783, 3102822469, 2261232318, 1657165783, 182571243, 2866887396, 4290974852, 2261061037, 3629684605, 2482236569, 1916603941, 3382603226, 999768427, 3171175558, 1709542380, 2086924233, 3964979595, 85833410, 1122206428, 1432694206, 4230090721, 2632877999, 834731838, 2344308939, 2399519878, 4086951271, 2681850703, 3113324115, 2045734372, 1980879301, 2869222671, 2270508944, 3549736736, 3871179085, 1302255582, 4224050094, 2185529812, 165196590, 2581134223, 579189627, 4045953032, 2910507974, 633486844, 4092863379, 279952867, 654229974, 3590879432, 3494667849, 3762736646, 4057616614, 1378958651, 3737744634, 2799387186, 127072071, 1886119253, 3542028713, 3083942542]</span><br><span class="line">for i in range(624):</span><br><span class="line">    predictor.setrandbits(x[i],32)</span><br><span class="line">a= [predictor.backtrack_getrandbits(32) for _ in range(628)]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>打印出来的a中最后四个数即为所需的向前还原的随机数。按提示即可得到flag。<br>本题中，由于给的output中的随机数没有以列表的形式给出，所以我用python3写了一个读取整数的脚本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">with open(&#x27;output.txt&#x27;, &#x27;r&#x27;) as file:</span><br><span class="line">    content = file.read()</span><br><span class="line">numbers = re.findall(r&#x27;\d+&#x27;, content)</span><br><span class="line">numbers = [int(num) for num in numbers]</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure>
<h2 id="22-NewStarCTF-公开赛赛道-Affine"><a href="#22-NewStarCTF-公开赛赛道-Affine" class="headerlink" title="22. [NewStarCTF 公开赛赛道]Affine"></a>22. [NewStarCTF 公开赛赛道]Affine</h2><p>这道题和第十五题一模一样，这次还提示了要使用flag的格式。</p>
<h2 id="23-变异凯撒"><a href="#23-变异凯撒" class="headerlink" title="23. 变异凯撒"></a>23. 变异凯撒</h2><p>这道题的题目为：<br>加密密文：<code>afZ_r9VYfScOeO_UL^RWUc</code><br>格式：<code>flag&#123; &#125;</code><br>说是变异凯撒，那肯定是和凯撒密码有关。一开始我以为密文中去掉下划线之后剩下的部分进行凯撒密码的变换之后可以得到三个单词，最后再包上flag{}进行提交。结果穷举了半天都没有找到什么合适的结果。<br>后来想起来其他题目好像都是说包上flag{}进行提交，而这个只说了格式是flag{}，我猜测是一个已知明文攻击的题目，就用前四个密文字符的ASCII码减去了flag对应的ASCII码，这才找到了这道题目的加密方法。用sagemath写的解密脚本如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;afZ_r9VYfScOeO_UL^RWUc&#x27;</span><br><span class="line">b=&#x27;&#x27;</span><br><span class="line">for i in range(len(a)):</span><br><span class="line">   b=b+chr(ord(a[i])+5+i)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<h2 id="24-Quoted-printable"><a href="#24-Quoted-printable" class="headerlink" title="24. Quoted-printable"></a>24. Quoted-printable</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/aaum556/article/details/132263994?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172224834616800178573185%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172224834616800178573185&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-132263994-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=Quoted-printable&spm=1018.2226.3001.4187">Quoted-printable_ 引用可打印-CSDN博客</a>这篇博客中有详细的介绍，具体的编码转换可以使用下面的网址：<a target="_blank" rel="noopener" href="http://web.chacuo.net/charsetquotedprintable">Quoted-printable编码|Quoted-printable解码|Quoted-printable编码原26理介绍–查错网</a></p>
<h2 id="25-篱笆墙的影子"><a href="#25-篱笆墙的影子" class="headerlink" title="25. 篱笆墙的影子"></a>25. 篱笆墙的影子</h2><p>题目为<code>felhaagv&#123;ewtehtehfilnakgw&#125;</code><br>根据提示是栅栏密码，找到{的位置，发现是第9位，前面单数位的字符刚好组成“flag”，很明显栏数为2，简单用sagemath写个脚本解密：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;felhaagv&#123;ewtehtehfilnakgw&#125;&#x27;</span><br><span class="line">b=&#x27;&#x27;</span><br><span class="line">for i in range(len(a)//2):</span><br><span class="line">    b=b+a[2*i]</span><br><span class="line">for i in range(len(a)//2):</span><br><span class="line">    b=b+a[2*i+1]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<h2 id="26-Rabbit"><a href="#26-Rabbit" class="headerlink" title="26. Rabbit"></a>26. Rabbit</h2><p>具体的编码方法可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/YueXuan_521/article/details/131316653?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172224992716800211582864%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172224992716800211582864&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-131316653-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=rabbit%E7%BC%96%E7%A0%81&spm=1018.2226.3001.4187">BUUCTF Rabbit 1-CSDN博客</a>这篇博客，其中用到的在线解密工具为<a target="_blank" rel="noopener" href="http://www.jsons.cn/rabbitencrypt/">Rabbit加密-Rabbit解密-在线Rabbit加密解密工具</a></p>
<h2 id="27-丢失的MD5"><a href="#27-丢失的MD5" class="headerlink" title="27. 丢失的MD5"></a>27. 丢失的MD5</h2><p>打开附件发现一个python代码，尝试运行，发现有报错。把报错的地方修改后即可运行得到正确答案，修改后的代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import hashlib   </span><br><span class="line">for i in range(32,127):</span><br><span class="line">    for j in range(32,127):</span><br><span class="line">        for k in range(32,127):</span><br><span class="line">            m=hashlib.md5()</span><br><span class="line">            m.update((&#x27;TASC&#x27;+chr(i)+&#x27;O3RJMV&#x27;+chr(j)+&#x27;WDJKX&#x27;+chr(k)+&#x27;ZM&#x27;).encode(&#x27;utf-8&#x27;))</span><br><span class="line">            des=m.hexdigest()</span><br><span class="line">            if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des:</span><br><span class="line">                print(des)</span><br></pre></td></tr></table></figure>
<h2 id="28-GKCTF2020-汉字的秘密"><a href="#28-GKCTF2020-汉字的秘密" class="headerlink" title="28. [GKCTF2020]汉字的秘密"></a>28. [GKCTF2020]汉字的秘密</h2><p>这道题中用汉字的笔划出头的数量来表示数字。<br>比如说“口”，没有出头，表示0，“由”有一个出头的笔划，表示1。把题目中涉及的所有汉字的笔划数计算出来，然后可以用sagemath写出下面的脚本解密：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;田口由中人工大土士王夫井羊壮&#x27;</span><br><span class="line">b=&#x27;00123455567899&#x27;</span><br><span class="line">c=&#x27;王壮夫工王中王夫由由井井人夫中夫夫井王土土夫由土夫井中士夫王工王人土由由口夫&#x27;</span><br><span class="line">s = &#x27;&#x27;</span><br><span class="line">for i in c:</span><br><span class="line">    s=s+b[a.index(i)]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>这样能得到一串数字‘69746267118837277865571578257646351107’，然后看给的文档里面汉字的组合情况，发现有些是两个汉字连在一起，有些是三个汉字连在一起，感觉像是每个字符的ASCII编码。根据提示将这些数值与flag中的字符的ASCII进行对比，发现这道题的加密方式与第二十三题变异凯撒差不多，于是可以用sagemath写出解密代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m=&#x27;69746267118837277865571578257646351107&#x27;</span><br><span class="line">s=&#x27;&#x27;</span><br><span class="line">for i in range(len(m)//2-2):</span><br><span class="line">    if i &lt;4:</span><br><span class="line">        x=int(m[2*i])*10+int(m[2*i+1])+i+1</span><br><span class="line">        s=s+chr(x)</span><br><span class="line">    elif i ==4:</span><br><span class="line">        x=100+int(m[2*i+1])*10+int(m[2*i+2])+i+1</span><br><span class="line">        s=s+chr(x)</span><br><span class="line">    else:</span><br><span class="line">        x=int(m[2*i+1])*10+int(m[2*i+2])+i+1</span><br><span class="line">        s=s+chr(x)</span><br><span class="line">s=s+chr(107+len(m)//2-1)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>最后得到的结果是大写的字母，按提示需要改成小写的字母进行提交。</p>
<h2 id="29-NewStarCTF-2023-公开赛道-Rabin’s-RSA"><a href="#29-NewStarCTF-2023-公开赛道-Rabin’s-RSA" class="headerlink" title="29. [NewStarCTF 2023 公开赛道]Rabin’s RSA"></a>29. [NewStarCTF 2023 公开赛道]Rabin’s RSA</h2><p>在rsa的rabin加密中，e取2，需要知道p、q的值才能解密，用sagemath写的具体的解密脚本如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">p=13934102561950901579</span><br><span class="line">q=14450452739004884887</span><br><span class="line">n=201354090531918389422241515534761536573 </span><br><span class="line">c=20442989381348880630046435751193745753 </span><br><span class="line">inv_p=int(pow(p,-1,q))</span><br><span class="line">inv_q=int(pow(q,-1,p))</span><br><span class="line">mp=int(pow(c,(p+1)//4,p))</span><br><span class="line">mq=int(pow(c,(q+1)//4,q))</span><br><span class="line">a=(inv_p*p*mq+inv_q*q*mp)%n</span><br><span class="line">b=n-int(a)</span><br><span class="line">c=(inv_p*p*mq-inv_q*q*mp)%n</span><br><span class="line">d=n-int(c)</span><br><span class="line">result=[a,b,c,d]</span><br><span class="line">for m in result:</span><br><span class="line">    t=hex(m)</span><br><span class="line">    g=str(t)</span><br><span class="line">    l=len(g)//2-1</span><br><span class="line">    s=&#x27;&#x27;</span><br><span class="line">    for i in range(l):</span><br><span class="line">        s=s+chr(int(g[2+2*i]+g[3+2*i],16))</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure>
<p>运行后得到的四段中只有一段是有效的flag，提交这一段即可。</p>
<h2 id="30-BJDCTF-2nd-燕言燕语-y1ng"><a href="#30-BJDCTF-2nd-燕言燕语-y1ng" class="headerlink" title="30. [BJDCTF 2nd]燕言燕语-y1ng"></a>30. [BJDCTF 2nd]燕言燕语-y1ng</h2><p>首先把给的十六进制的数用ASCII码编码为对应的字符，得到：<br><code>yanzi ZJQ&#123;xilzv_iqssuhoc_suzjg&#125;</code><br>后面的部分显然是flag经过维吉尼亚密码变换后得到的结果，尝试猜测明文。首先这个比赛是BJDCTF，所以ZJQ大概率是由BJD变换过来的。再看到前面的“yanzi”刚好有五个字符，而大括号里面下划线隔开的部分中也有两个部分刚好是由五个字符组成的，可以合理猜测这两个里面有一个就是“yanzi”这五个字符。先尝试前面这五个字符，发现正好能解密出一句完整的话，成功获取到flag。<br>这道题的关键在于明文的猜测，也就是需要理解出题人给的“yanzi”这个提示的含义。因为在flag里面组成的话一般都是英语的，所以我一开始以为这是什么特殊的加密方法。百度之后没有什么收获，最后才知道这个提示原来就是明文的一部分。</p>
<h2 id="31-信息化时代的步伐"><a href="#31-信息化时代的步伐" class="headerlink" title="31. 信息化时代的步伐"></a>31. 信息化时代的步伐</h2><p>这是一种中文电码，可以使用下面的网站解码：<a target="_blank" rel="noopener" href="http://code.mcdvisa.com/">中文电码查询 Chinese Commercial Code - 标准电报码免费在线查询|姓名电码|美国签证电码</a></p>
<h2 id="32-凯撒？替换？呵呵"><a href="#32-凯撒？替换？呵呵" class="headerlink" title="32. 凯撒？替换？呵呵!"></a>32. 凯撒？替换？呵呵!</h2><p>记录一个可以很方便列举凯撒密码的可能性的网站：<a target="_blank" rel="noopener" href="https://quipqiup.com/">quipqiup - cryptoquip and cryptogram solver</a></p>
<h2 id="33-萌萌哒的八戒"><a href="#33-萌萌哒的八戒" class="headerlink" title="33. 萌萌哒的八戒"></a>33. 萌萌哒的八戒</h2><p>看到八戒和密码就知道是猪圈密码，这里记录一个猪圈密码的图片。<br>（图片参考:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40837276/article/details/83080460?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172240020116800180633253%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172240020116800180633253&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-83080460-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=%E7%8C%AA%E5%9C%88%E5%AF%86%E7%A0%81&spm=1018.2226.3001.4187">CTF密码学常见加密解密总结_wydfxjmgvswodododod-CSDN博客</a>）</p>
<h2 id="34-传统知识-古典密码"><a href="#34-传统知识-古典密码" class="headerlink" title="34. 传统知识+古典密码"></a>34. 传统知识+古典密码</h2><p>这道题中使用到了我国传统的天干地支，这里附一张天干地支的计数表：<br>题目中提示说“+甲子”，甲子在表里面表示1，但是把解密出来的数字加一并没有什么效果，所以想到甲子还有另一层意思，就是一轮，也就是六十，再把解密出来的数字加六十，用ASCII码找到对应的英文字符，即可得到一串没有任何意义的字母。<br>看到题目里有“古典密码”的提示，使用<a target="_blank" rel="noopener" href="https://ctf.bugku.com/tools">在线工具 - Bugku CTF</a>中的栅栏加密和凯撒加密的工具进行穷举，终于找到了一串有含义的中文拼音：<code>SHUANGYU</code>，包上flag提交即可。</p>
<h2 id="35-AFCTF2018-Morse"><a href="#35-AFCTF2018-Morse" class="headerlink" title="35. [AFCTF2018]Morse"></a>35. [AFCTF2018]Morse</h2><p>这也是一道摩斯编码的题目，由于摩斯码较长，找了一个解码的网站：<a target="_blank" rel="noopener" href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx">摩尔斯电码转换器：在线进行摩尔斯电码和英文字母的相互转换，可以把莫尔斯电码转换为英文字母，也可把英文字母转换为摩尔斯电码</a></p>
<h2 id="36-NewStarCTF-2023-公开赛道-RSA-Variation-II"><a href="#36-NewStarCTF-2023-公开赛道-RSA-Variation-II" class="headerlink" title="36.[NewStarCTF 2023 公开赛道]RSA Variation II"></a>36.[NewStarCTF 2023 公开赛道]RSA Variation II</h2><p>根据提示知道是一种Schmidt-Samoa密码系统，可以通过推导得到计算flag的方法。<br>易知，用sagemath写出脚本：   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">N = 1768427447158131856514034889456397424027937796617829756303525705316152314769129050888899742667986532346611229157207778487065194513722005516611969754197481310330149721054855689646133721600838194741123290410384315980339516947257172981002480414254023253269098539962527834174781356657779988761754582343096332391763560921491414520707112852896782970123018263505426447126195645371941116395659369152654368118569516482251442513192892626222576419747048343942947570016045016127917578272819812760632788343321742583353340158009324794626006731057267603803701663256706597904789047060978427573361035171008822467120148227698893238773305320215769410594974360573727150122036666987718934166622785421464647946084162895084248352643721808444370307254417501852264572985908550839933862563001186477021313236113690793843893640190378131373214104044465633483953616402680853776480712599669132572907096151664916118185486737463253559093537311036517461749439</span><br><span class="line">d = 20650646933118544225095544552373007455928574480175801658168105227037950105642248948645762488881219576174131624593293487325329703919313156659700002234392400636474610143032745113473842675857323774566945229148664969659797779146488402588937762391470971617163496433008501858907585683428652637958844902909796849080799141999490231877378863244093900363251415972834146031490928923962271054053278056347181254936750536280638321211545167520935870220829786490686826062142415755063724639110568511969041175019898031990455911525941036727091961083201123910761290998968240338217895275414072475701909497518616112236380389851984377079</span><br><span class="line">pq = gcd(Integer(pow(2,d*N,N)-2),Integer(pow(3,d*N,N)-3))</span><br><span class="line">p=N//pq</span><br><span class="line">q=pq//p</span><br><span class="line">print(p)</span><br><span class="line">print(q)</span><br></pre></td></tr></table></figure>
<p>易知，可以得到flag。</p>
<h2 id="37-NewStarCTF-2023-公开赛道-Small-d"><a href="#37-NewStarCTF-2023-公开赛道-Small-d" class="headerlink" title="37. [NewStarCTF 2023 公开赛道]Small d"></a>37. [NewStarCTF 2023 公开赛道]Small d</h2><p>根据提示需要使用维纳攻击的方法，到网上找了一个相关的脚本，用sagemath运行一下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">def rational_to_contfrac(x,y):</span><br><span class="line">    a = x // y</span><br><span class="line">    pquotients = [a]</span><br><span class="line">    while a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        pquotients.append(a)</span><br><span class="line">    return pquotients</span><br><span class="line">def convergents_from_contfrac(frac):</span><br><span class="line">    convs = [];</span><br><span class="line">    for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i]))</span><br><span class="line">    return convs</span><br><span class="line">def contfrac_to_rational (frac):</span><br><span class="line">    if len(frac) == 0: return (0,1)</span><br><span class="line">    num = frac[-1]</span><br><span class="line">    denom = 1</span><br><span class="line">    for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num</span><br><span class="line">    return (num, denom)</span><br><span class="line">c = 6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248</span><br><span class="line">e = 8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825</span><br><span class="line">n = 19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433</span><br><span class="line">def egcd(a, b):</span><br><span class="line">    if a == 0: return (b, 0, 1)</span><br><span class="line">    g, x, y = egcd(b % a, a)</span><br><span class="line">    return (g, y - (b // a) * x, x)</span><br><span class="line">def mod_inv(a, m):</span><br><span class="line">    g, x, _ = egcd(a, m)</span><br><span class="line">    return (x + m) % m</span><br><span class="line">def isqrt(n):</span><br><span class="line">    x = n</span><br><span class="line">    y = (x + 1) // 2</span><br><span class="line">    while y &lt; x:</span><br><span class="line">        x = y</span><br><span class="line">        y = (x + n // x) // 2</span><br><span class="line">    return x</span><br><span class="line">def crack_rsa(e, n):</span><br><span class="line">    frac = rational_to_contfrac(e, n)</span><br><span class="line">    convergents = convergents_from_contfrac(frac)</span><br><span class="line">    for (k, d) in convergents:</span><br><span class="line">        if k != 0 and (e * d - 1) % k == 0:</span><br><span class="line">            phi = (e * d - 1) // k</span><br><span class="line">            s = n - phi + 1</span><br><span class="line">            # check if x*x - s*x + n = 0 has integer roots</span><br><span class="line">            D = s * s - 4 * n</span><br><span class="line">            if D &gt;= 0:</span><br><span class="line">                sq = isqrt(D)</span><br><span class="line">                if sq * sq == D and (s + sq) % 2 == 0: return d</span><br><span class="line">d = crack_rsa(e, n)</span><br><span class="line">m = hex(pow(c, d, n))[2:]</span><br><span class="line">print(bytes.fromhex(m))</span><br></pre></td></tr></table></figure>
<h2 id="38-NewStarCTF-公开赛赛道-ezRabin"><a href="#38-NewStarCTF-公开赛赛道-ezRabin" class="headerlink" title="38. [NewStarCTF 公开赛赛道]ezRabin"></a>38. [NewStarCTF 公开赛赛道]ezRabin</h2><p>这道题里面e使用了4，是2的两倍，所以只要使用两次rabin加密的解密算法就能得到结果，直接上sagemath的脚本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">c=59087040011818617875466940950576089096932769518087477304162753047334728508009365510335057824251636964132317478310267427589970177277870220660958570994888152191522928881774614096675980017700457666192609573774572571582962861504174396725705862549311100229145101667835438230371282904888448863223898642183925834109</span><br><span class="line">p=10522889477508921233145726452630168129218487981917965097647277937267556441871668611904567713868254050044587941828674788953975031679913879970887998582514571</span><br><span class="line">q=11287822338267163056031463255265099337492571870189068887689824393221951058498526362126606231275830844407608185240702408947800715624427717739233431252556379</span><br><span class="line">n=p*q</span><br><span class="line">inv_p=int(pow(p,-1,q))</span><br><span class="line">inv_q=int(pow(q,-1,p))</span><br><span class="line">mp=int(pow(c,(p+1)//4,p))</span><br><span class="line">mq=int(pow(c,(q+1)//4,q))</span><br><span class="line">a=(inv_p*p*mq+inv_q*q*mp)%n</span><br><span class="line">b=n-int(a)</span><br><span class="line">c=(inv_p*p*mq-inv_q*q*mp)%n</span><br><span class="line">d=n-int(c)</span><br><span class="line">result=[a,b,c,d]</span><br><span class="line">re=[]</span><br><span class="line">for m in result:</span><br><span class="line">    mp=int(pow(m,(p+1)//4,p))</span><br><span class="line">    mq=int(pow(m,(q+1)//4,q))</span><br><span class="line">    a=(inv_p*p*mq+inv_q*q*mp)%n</span><br><span class="line">    b=n-int(a)</span><br><span class="line">    c=(inv_p*p*mq-inv_q*q*mp)%n</span><br><span class="line">    d=n-int(c)</span><br><span class="line">    re.append(a)</span><br><span class="line">    re.append(b)</span><br><span class="line">    re.append(c)</span><br><span class="line">    re.append(d)</span><br><span class="line">for m in re:</span><br><span class="line">    m=m&gt;&gt;300</span><br><span class="line">    t=hex(m)</span><br><span class="line">    g=str(t)</span><br><span class="line">    l=len(g)//2-1</span><br><span class="line">    s=&#x27;&#x27;</span><br><span class="line">    for i in range(l):</span><br><span class="line">        s=s+chr(int(g[2+2*i]+g[3+2*i],16))</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure>
<h2 id="39-NewStarCTF-2023-公开赛道-partial-decrypt"><a href="#39-NewStarCTF-2023-公开赛道-partial-decrypt" class="headerlink" title="39. [NewStarCTF 2023 公开赛道]partial decrypt"></a>39. [NewStarCTF 2023 公开赛道]partial decrypt</h2><p>易知，可以计算出m的值。</p>
<h2 id="40-V-N2020-公开赛-CRT"><a href="#40-V-N2020-公开赛-CRT" class="headerlink" title="40. [V&amp;N2020 公开赛]CRT"></a>40. [V&amp;N2020 公开赛]CRT</h2><p>这是一道扩展的中国剩余定理的题目，直接上大佬的脚本得到所需求的数的模数和取模之后的值，然后遍历所有可能的结果，寻找符合条件的结果，即为最终的flag。下面是修改后sagemath的脚本：   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">def CRT(mi, ai):</span><br><span class="line">	curm, cura = mi[0], ai[0]</span><br><span class="line">	for (m, a) in zip(mi[1:], ai[1:]):</span><br><span class="line">		d =gcd(curm, m)</span><br><span class="line">		c = a - cura</span><br><span class="line">		assert (c % d == 0) </span><br><span class="line">		K = c // d * gmpy2.invert(curm // d, m // d)</span><br><span class="line">		cura += curm * K</span><br><span class="line">		curm = curm * m // d</span><br><span class="line">	return (cura % curm, curm) </span><br><span class="line">ms = [284461942441737992421992210219060544764, 218436209063777179204189567410606431578, 288673438109933649911276214358963643204, 239232622368515797881077917549177081575, 206264514127207567149705234795160750411, 338915547568169045185589241329271490503, 246545359356590592172327146579550739141, 219686182542160835171493232381209438048]</span><br><span class="line">cs = [273520784183505348818648859874365852523, 128223029008039086716133583343107528289, 5111091025406771271167772696866083419, 33462335595116820423587878784664448439, 145377705960376589843356778052388633917, 128158421725856807614557926615949143594, 230664008267846531848877293149791626711, 94549019966480959688919233343793910003]</span><br><span class="line">(x,y)=CRT(ms,cs)</span><br><span class="line">x=int(x)</span><br><span class="line">y=int(y)</span><br><span class="line">x=331928385895936850327248455618550267979226366540503309505403897762924348214252184339508819167395418477591466337317495869131189862837240599867138359384794556128835111222068761517340369160010091387517644467690158341517036316714577728109817419385351326590048046021467528943086247709683222909672931154665939</span><br><span class="line">y=466244535277126133494171720905467305227449898136540531771165702728811600035193763296997575538712880600873766336223021102495903920660547449598419752724436481022338453912400904360309909376397024992632893902959636099041017419464716113173886710394215080355542879719231888389121865360597540403463754208728800</span><br><span class="line">k=1</span><br><span class="line">while True:</span><br><span class="line">    flag = &quot;flag&#123;&quot; + hashlib.sha256(str(x+k*y).encode()).hexdigest() + &quot;&#125;&quot;</span><br><span class="line">    if &quot;4b93deeb&quot; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br><span class="line">    k+=1</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" data-id="cm1egdhsy0003q0twc87r4fg1" data-title="BUUCTF刷题记录" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf-crypto/" rel="tag">ctf crypto</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-web" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/web/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:19:15.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/web/">web</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="MD5弱碰撞"><a href="#MD5弱碰撞" class="headerlink" title="MD5弱碰撞"></a>MD5弱碰撞</h2><p>PHP在处理哈希字符串时，会利用”!&#x3D;”或”&#x3D;&#x3D;”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。攻击者可以利用这一漏洞，通过输入一个经过哈希后以”0E”开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以”0E”开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。<br>以下是一些0e开头的字符串：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QNKCDZO</span><br><span class="line">0e830400451993494058024219903391</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/web/" data-id="cm1egdht70009q0tw6vpvgsv1" data-title="web" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf-web/" rel="tag">ctf web</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-crypto" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/crypto/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:18:43.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/crypto/">crypto</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><p><a target="_blank" rel="noopener" href="http://factordb.com/">因数分解网站</a>  </p>
<h3 id="e的值很小"><a href="#e的值很小" class="headerlink" title="e的值很小"></a>e的值很小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	import gmpy2</span><br><span class="line">	n = </span><br><span class="line">	e = </span><br><span class="line">	c = </span><br><span class="line">	//导入n，e，c的值</span><br><span class="line">	for i in range(10000):   //遍历循环，找到m值</span><br><span class="line">	    m, t = gmpy2.iroot(i*n + c, e)</span><br><span class="line">	    if t:</span><br><span class="line">	        print(bytearray.fromhex(format(m, &#x27;x&#x27;)).decode()) //将十六进制字符串转换为字节后解密</span><br><span class="line">        	break</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">### 两次加密存在一个相同的质数  </span><br></pre></td></tr></table></figure>
<pre><code>from Crypto.Util.number import *
from gmpy2 import powmod as po, gmpy2
import sympy
c1 = 
c2 = 
n1 = 
n2 = 
e = 
q = gmpy2.gcd(n1, n2)  # 求n1和n2的最大公因数
p1 = n1 // q
p2 = n2 // q
fn1 = (q - 1) * (p1 - 1)  # 求下面的&amp;n
fn2 = (q - 1) * (p2 - 1)  # 求上面的&amp;n
d1 = inverse(e, fn1)  # (de)mod((p-1)*(q-1))=1  求到第一个解密密钥d1
d2 = inverse(e, fn2)  # 求出第二个解密密钥d2
m1 = pow(c1, d1, n1)
m2 = pow(c2, d2, n2)
print(long_to_bytes(m1))
print(long_to_bytes(m2))
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 同一个n用两个e进行加密</span><br></pre></td></tr></table></figure>
<pre><code>from gmpy2 import *
from Crypto.Util.number import *
from gmpy2 import gmpy2
flag1 = 
flag2 = 
e1 = 
e2 = 
n = 
def rsa_gong_N_def(e1, e2, c1, c2, n):
    e1, e2, c1, c2, n = int(e1), int(e2), int(c1), int(c2), int(n)
    s = gmpy2.gcdext(e1, e2)  # 扩展欧几里得算法  t*e1+z*e2=1,求出t和z
    t = s[1]
    z = s[2]
    if t &lt; 0:  # 要求c的s次幂，就要先计算c的模反元素c2r，然后求c2r的-s2次幂
        t = - t
        c1 = gmpy2.invert(c1, n)  # 求c1的逆元
    elif z &lt; 0:
        z = -z
        c2 = gmpy2.invert(c2, n)
    m = (pow(c1, t, n) * pow(c2, z, n)) % n  # (c1^s1*c2^s2)%n=m%n=m
    return m
result = rsa_gong_N_def(e1, e2, flag1, flag2, n)
print(long_to_bytes(result))
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 有四个质数，其中两个是另外两个的next_prime，已知他们四个数的乘积</span><br></pre></td></tr></table></figure>
<pre><code>import gmpy2
from gmpy2 import *
from Crypto.Util.number import *
import sympy
e = 
n1 = 
c1 = 
def fermat_factorization(n):
    factor_list = []
    get_context().precision = 2048	
    sqrt_n = int(sqrt(n))
    c = sqrt_n
    while True:
        c += 1
        d_square = c**2 - n
        if is_square(d_square):
            d_square = mpz(d_square)
            get_context().precision = 2048
            d = int(sqrt(d_square))
            factor_list.append([c+d,c-d])
        if len(factor_list)==2:
            break
    return factor_list
factor_list = fermat_factorization(n1)
[X1,Y1] = factor_list[0]	#费马函数分解
[X2,Y2] = factor_list[1]
assert X1*Y1 == n1
assert X2*Y2 == n1
p1 = gcd(X1,X2)
q1 = X1 // p1		
p2 = gcd(Y1,Y2)
q2 = Y1 // p2
phi1 = (p1-1)*(q1-1)*(p2-1)*(q2-1)	#求φ(n)
d1 = invert(e,phi1)		#常规RSA解密流程求d
print(long_to_bytes(gmpy2.powmod(c1,d1,n1)),end=&#39;&#39;)	##常规RSA解密流程求明文
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### dp泄露</span><br></pre></td></tr></table></figure>
<pre><code>from gmpy2 import *
from Crypto.Util.number import *
def rsa(e,n,dp,c):
    p=0
    for i in range(1,e):
        if (e*dp-1)%i==0:
            p=(e*dp-1)//i+1
            if n%p==0:
                break
    q=n//p
    d=invert(e,(p-1)*(q-1))
    print(long_to_bytes(pow(c,d,n)))
if __name__ == &quot;__main__&quot;:
    e =
    n = 
    dp = 
    c = 
    rsa(e,n,dp,c)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 维纳攻击方法（当e的值非常大的时候使用）</span><br><span class="line">文件1：Arithmetic.py（后面引用，勿改名）  </span><br></pre></td></tr></table></figure>
<pre><code>def egcd(a,b):
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a
def gcd(a,b):
    a,b=(b,a) if a&lt;b else (a,b)
    while b:
        a,b=b,a%b
    return a
def modInverse(e,n):
    return egcd(e,n)[0]%n
def totient(p,q):
    return (p-1)*(q-1)
def bitlength(x):
    assert x &gt;= 0
    n = 0
    while x &gt; 0:
        n = n+1
        x = x&gt;&gt;1
    return n
def isqrt(n):
    if n &lt; 0:
        raise ValueError(&#39;square root not defined for negative numbers&#39;)
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y &gt;= x:
            return x
        x = y
def is_perfect_square(n):
    h = n &amp; 0xF; 
    if h &gt; 9:
        return -1 
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    return -1
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件2：ContinuedFractions.py（后面引用，勿改名）  </span><br></pre></td></tr></table></figure>
<pre><code>from typing import List,Tuple
CFListT = List[int]  
CVListT = List[Tuple[int, int]] 
def rational_to_contfrac(x: int, y: int) -&gt; Tuple[CFListT, CVListT]:
    a = x // y
    cflist = [a]
    cvlist = [(a, 1)]
    ppn, ppd = 1, 0 
    pn, pd = a, 1  
    while a * y != x:
        x, y = y, x - a * y
        a = x // y
        cflist.append(a)
        cn, cd = a * pn + ppn, a * pd + ppd
        cvlist.append((cn, cd))
        ppn, ppd = pn, pd
        pn, pd = cn, cd
return cflist, cvlist
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件3：运行的文件，可随意取名</span><br></pre></td></tr></table></figure>
<pre><code>import gmpy2
from gmpy2 import *
from Crypto.Util.number import *
import sympy
import ContinuedFractions, Arithmetic
def hack_RSA(e,n):
    _, convergents = ContinuedFractions.rational_to_contfrac(e, n)   
    for (k,d) in convergents:
        if k!=0 and (e*d-1)%k == 0:
            phi = (e*d-1)//k
            s = n - phi + 1
            discr = s*s - 4*n
            if(discr&gt;=0):
                t = Arithmetic.is_perfect_square(discr)
                if t!=-1 and (s+t)%2==0:
                    print(&quot;Hacked!&quot;)
                    return d
e=
n=
ct=
d=hack_RSA(e,n)
print(d)
h=pow(  ct, d, n)
print(h)
print(long_to_bytes(h))
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### RSA中的Boneh Durfee Attack攻击方法</span><br><span class="line">参考[链接](https://blog.csdn.net/shshss64/article/details/129605810?app_version=6.3.7&amp;code=app_1562916241&amp;csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22129605810%22%2C%22source%22%3A%222301_79140522%22%7D&amp;uLinkId=usr1mkqgl919blen&amp;utm_source=app )</span><br></pre></td></tr></table></figure>
<pre><code>import time
debug = True
strict = False
helpful_only = True
dimension_min = 7 # stop removing if lattice reaches that dimension
def helpful_vectors(BB, modulus):
    nothelpful = 0
    for ii in range(BB.dimensions()[0]):
        if BB[ii,ii] &gt;= modulus:
            nothelpful += 1
    print(nothelpful, &quot;/&quot;, BB.dimensions()[0], &quot; vectors are not helpful&quot;)
# display matrix picture with 0 and X
def matrix_overview(BB, bound):
    for ii in range(BB.dimensions()[0]):
        a = (&#39;%02d &#39; % ii)
        for jj in range(BB.dimensions()[1]):
            a += &#39;0&#39; if BB[ii,jj] == 0 else &#39;X&#39;
            if BB.dimensions()[0] &lt; 60:
                a += &#39; &#39;
        if BB[ii, ii] &gt;= bound:
            a += &#39;~&#39;
        print(a)
def remove_unhelpful(BB, monomials, bound, current):
    # end of our recursive function
    if current == -1 or BB.dimensions()[0] &lt;= dimension_min:
        return BB
    # we start by checking from the end
    for ii in range(current, -1, -1):
        # if it is unhelpful:
        if BB[ii, ii] &gt;= bound:
            affected_vectors = 0
            affected_vector_index = 0
            # let&#39;s check if it affects other vectors
            for jj in range(ii + 1, BB.dimensions()[0]):
                if BB[jj, ii] != 0:
                    affected_vectors += 1
                    affected_vector_index = jj
            if affected_vectors == 0:
                print(&quot;* removing unhelpful vector&quot;, ii)
                BB = BB.delete_columns([ii])
                BB = BB.delete_rows([ii])
                monomials.pop(ii)
                BB = remove_unhelpful(BB, monomials, bound, ii-1)
                return BB
            elif affected_vectors == 1:
                affected_deeper = True
                for kk in range(affected_vector_index + 1, BB.dimensions()[0]):
                    if BB[kk, affected_vector_index] != 0:
                        affected_deeper = False
                if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]):
                    print(&quot;* removing unhelpful vectors&quot;, ii, &quot;and&quot;, affected_vector_index)
                    BB = BB.delete_columns([affected_vector_index, ii])
                    BB = BB.delete_rows([affected_vector_index, ii])
                    monomials.pop(affected_vector_index)
                    monomials.pop(ii)
                    BB = remove_unhelpful(BB, monomials, bound, ii-1)
                    return BB
    # nothing happened
    return BB
def boneh_durfee(pol, modulus, mm, tt, XX, YY):
    # substitution (Herrman and May)
    PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)
    Q = PR.quotient(x*y + 1 - u) # u = xy + 1
    polZ = Q(pol).lift()

    UU = XX*YY + 1

    gg = []
    for kk in range(mm + 1):
        for ii in range(mm - kk + 1):
            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk
            gg.append(xshift)
    gg.sort()

    # x-shifts list of monomials
    monomials = []
    for polynomial in gg:
        for monomial in polynomial.monomials():
            if monomial not in monomials:
                monomials.append(monomial)
    monomials.sort()

    # y-shifts (selected by Herrman and May)
    for jj in range(1, tt + 1):
        for kk in range(floor(mm/tt) * jj, mm + 1):
            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)
            yshift = Q(yshift).lift()
            gg.append(yshift) # substitution

    # y-shifts list of monomials
    for jj in range(1, tt + 1):
        for kk in range(floor(mm/tt) * jj, mm + 1):
            monomials.append(u^kk * y^jj)
 
    # construct lattice B
    nn = len(monomials)
    BB = Matrix(ZZ, nn)
    for ii in range(nn):
        BB[ii, 0] = gg[ii](0, 0, 0)
        for jj in range(1, ii + 1):
            if monomials[jj] in gg[ii].monomials():
                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)
    if helpful_only:
        BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1)
        nn = BB.dimensions()[0]
        if nn == 0:
            print(&quot;failure&quot;)
            return 0,0
    if debug:
        helpful_vectors(BB, modulus^mm)
    det = BB.det()
    bound = modulus^(mm*nn)
    if det &gt;= bound:
        print(&quot;We do not have det &lt; bound. Solutions might not be found.&quot;)
        print(&quot;Try with highers m and t.&quot;)
        if debug:
            diff = (log(det) - log(bound)) / log(2)
            print(&quot;size det(L) - size e^(m*n) = &quot;, floor(diff))
        if strict:
            return -1, -1
    else:
        print(&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;)
    if debug:
        matrix_overview(BB, modulus^mm)
    if debug:
        print(&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;)

    BB = BB.LLL()

    if debug:
        print(&quot;LLL is done!&quot;)
    if debug:
        print(&quot;looking for independent vectors in the lattice&quot;)
    found_polynomials = False
    
    for pol1_idx in range(nn - 1):
        for pol2_idx in range(pol1_idx + 1, nn):
            # for i and j, create the two polynomials
            PR.&lt;w,z&gt; = PolynomialRing(ZZ)
            pol1 = pol2 = 0
            for jj in range(nn):
                pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)
                pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)
            PR.&lt;q&gt; = PolynomialRing(ZZ)
            rr = pol1.resultant(pol2)
            if rr.is_zero() or rr.monomials() == [1]:
                continue
            else:
                print(&quot;found them, using vectors&quot;, pol1_idx, &quot;and&quot;, pol2_idx)
                found_polynomials = True
                break
        if found_polynomials:
            break 
    if not found_polynomials:
        print(&quot;no independant vectors could be found. This should very rarely happen...&quot;)
        return 0, 0 
    rr = rr(q, q)
    soly = rr.roots() 
    if len(soly) == 0:
        print(&quot;Your prediction (delta) is too small&quot;)
        return 0, 0

    soly = soly[0][0]
    ss = pol1(q, soly)
    solx = ss.roots()[0][0]
    return solx, soly

def example(): 
    N =     # the public exponent
    e = 
    c = 
    delta = .28 # this means that d &lt; N^delta
    m = 4 # size of the lattice (bigger the better/slower)
    t = int((1-2*delta) * m)  # optimization from Herrmann and May
    X = 2*floor(N^delta)  # this _might_ be too much
    Y = floor(N^(1/2))    # correct if p, q are ~ same size
    P.&lt;x,y&gt; = PolynomialRing(ZZ)
    A = int((N+1)/2)
    pol = 1 + x * (A + y)
    if debug:
        print(&quot;=== checking values ===&quot;)
        print(&quot;* delta:&quot;, delta)
        print(&quot;* delta &lt; 0.292&quot;, delta &lt; 0.292)
        print(&quot;* size of e:&quot;, int(log(e)/log(2)))
        print(&quot;* size of N:&quot;, int(log(N)/log(2)))
        print(&quot;* m:&quot;, m, &quot;, t:&quot;, t)

    if debug:
        print(&quot;=== running algorithm ===&quot;)
        start_time = time.time()

    solx, soly = boneh_durfee(pol, e, m, t, X, Y)
 
    if solx &gt; 0:
        print(&quot;=== solution found ===&quot;)
        if False:
            print(&quot;x:&quot;, solx)
            print(&quot;y:&quot;, soly)
 
        d = int(pol(solx, soly) / e)
        print(&quot;private key found:&quot;, d)
        print(&quot;plaintext:&quot;, pow(c, d, N))
    else:
        print(&quot;=== no solution was found ===&quot;)

    if debug:
        print(&quot;=== %s seconds ===&quot; % (time.time() - start_time))

if __name__ == &quot;__main__&quot;:
    example()
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## prng算法（利用random.getrandbits函数只能产生固定数量的随机数）（梅森旋转算法）</span><br><span class="line">### 向后恢复随机数</span><br></pre></td></tr></table></figure>
<pre><code>from hashlib import sha256
from randcrack import RandCrack //该库专门用来梅森旋转算法的破解
t=[]
rc = RandCrack()
for i in t:
    rc.submit(i)
flag1 = rc.predict_getrandbits(32)
flag2 = rc.predict_getrandbits(32)
print(sha256((str(flag1)+str(flag2)).encode()).hexdigest())
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用别人写的脚本    </span><br></pre></td></tr></table></figure>
<pre><code>from random import Random
def inverse_right(res,shift,bits=32):
    tmp=res
    for i in range(bits//shift):
        tmp=res^tmp&gt;&gt;shift
    return tmp
def inverse_left_mask(res,shift,mask,bits=32):
    tmp=res
    for i in range(bits//shift):
        tmp=res^tmp&lt;&lt;shift&amp;mask
    return tmp
def inv_extract_number(y):
    y=inverse_right(y,18)
    y=inverse_left_mask(y,15,4022730752)
    y=inverse_left_mask(y,7,2636928640)
    y=inverse_right(y,11)
    return y&amp;0xffffffff
def recover_mt(record):
    state=[inv_extract_number(i) for i in record][:624]
    gen=Random()
    gen.setstate((3,tuple(state+[0]),None))
    return gen
ss=[]
mt=recover_mt(ss)
for i in range(624):
    mt.getrandbits(32)
print(mt.getrandbits(32))
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 向前恢复随机数  </span><br><span class="line">首先下载库  </span><br></pre></td></tr></table></figure>
<p>$ pip install extend_mt19937_predictor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">然后使用代码  </span><br></pre></td></tr></table></figure>
<pre><code>from extend_mt19937_predictor import ExtendMT19937Predictor
numbers = []
predictor = ExtendMT19937Predictor()

for i in range(628):
    predictor.setrandbits(numbers[i], 32)
result = [predictor.backtrack_getrandbits(32) for _ in range(625)]
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">梅森旋转算法（亲测有效）  </span><br></pre></td></tr></table></figure>
<pre><code>from Crypto.Util.number import *
from hashlib import md5
import random
def _int32(x):
    return int(0xFFFFFFFF &amp; x)
class MT19937:
    def __init__(self, seed=0):
        self.mt = [0] * 624
        self.mt[0] = seed
        self.mti = 0
        for i in range(1, 624):
            self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] &gt;&gt; 30) + i)
    def getstate(self,op=False):
        if self.mti == 0 and op==False:
            self.twist()
        y = self.mt[self.mti]
        y = y ^ y &gt;&gt; 11
        y = y ^ y &lt;&lt; 7 &amp; 2636928640
        y = y ^ y &lt;&lt; 15 &amp; 4022730752
        y = y ^ y &gt;&gt; 18
        self.mti = (self.mti + 1) % 624
        return _int32(y)
    def twist(self):
        for i in range(0, 624):
            y = _int32((self.mt[i] &amp; 0x80000000) + (self.mt[(i + 1) % 624] &amp; 0x7fffffff))
        self.mt[i] = (y &gt;&gt; 1) ^ self.mt[(i + 397) % 624]
            if y % 2 != 0:
                self.mt[i] = self.mt[i] ^ 0x9908b0df
    def inverse_right(self,res, shift, mask=0xffffffff, bits=32):
        tmp = res
        for i in range(bits // shift):
            tmp = res ^ tmp &gt;&gt; shift &amp; mask
        return tmp
    def inverse_left(self,res, shift, mask=0xffffffff, bits=32):
        tmp = res
        for i in range(bits // shift):
            tmp = res ^ tmp &lt;&lt; shift &amp; mask
        return tmp
    def extract_number(self,y):
        y = y ^ y &gt;&gt; 11
        y = y ^ y &lt;&lt; 7 &amp; 2636928640
        y = y ^ y &lt;&lt; 15 &amp; 4022730752
        y = y ^ y &gt;&gt; 18
        return y&amp;0xffffffff
    def recover(self,y):
        y = self.inverse_right(y,18)
        y = self.inverse_left(y,15,4022730752)
        y = self.inverse_left(y,7,2636928640)
        y = self.inverse_right(y,11)
        return y&amp;0xffffffff
    def setstate(self,s):
        if(len(s)!=624):
            raise ValueError(&quot;The length of prediction must be 624!&quot;)
        for i in range(624):
            self.mt[i]=self.recover(s[i])
        #self.mt=s
        self.mti=0
    def predict(self,s):
        self.setstate(s)
        self.twist()
        return self.getstate(True)
    def invtwist(self):
        high = 0x80000000
        low = 0x7fffffff
        mask = 0x9908b0df
        for i in range(623,-1,-1):
            tmp = self.mt[i]^self.mt[(i+397)%624]
            if tmp &amp; high == high:
                tmp ^= mask
                tmp &lt;&lt;= 1
                tmp |= 1
            else:
                tmp &lt;&lt;=1
            res = tmp&amp;high
            tmp = self.mt[i-1]^self.mt[(i+396)%624]
            if tmp &amp; high == high:
                tmp ^= mask
                tmp &lt;&lt;= 1
                tmp |= 1
            else:
                tmp &lt;&lt;=1
            res |= (tmp)&amp;low
            self.mt[i] = res
def example():
    D=MT19937(48)
    print(D.getstate())
    print(D.mt[:5])
    print(D.recover(90324435))
    print(D.extract_number(90324435))
    D.twist()
    print(D.mt[:5])
    D.invtwist()
    print(D.mt[:5])
example()#Main Below
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## ecc</span><br><span class="line">### p、a、b的值较小的时候：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>p =  
a =   
b =   
E = EllipticCurve(GF(p),[a,b])  
P = E(,)
Q = E(,)
k =  discrete_log(Q,P,operation = &#39;+&#39;)
print(k)
</code></pre>
<pre><code>
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/crypto/" data-id="cm1egdhsp0000q0twdx1qhoo5" data-title="crypto" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf-crypto/" rel="tag">ctf crypto</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-pwn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/pwn/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T04:25:58.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/pwn/">pwn</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>首先是一个github上面感觉非常强的<a target="_blank" rel="noopener" href="https://github.com/Dvd848/CTFs/tree/master/2018_35C3_Junior/Wee/">文章</a></p>
<h1 id="gdb的使用"><a href="#gdb的使用" class="headerlink" title="gdb的使用"></a>gdb的使用</h1><p>查看栈内情况</p>
<figure class="highlight plaintext"><figcaption><span>byte $eax</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x /24bx $eax</span><br><span class="line">hexdump byte $esp+0x4 32</span><br></pre></td></tr></table></figure>

<p>使用终端得到汇编代码对应的十六进制</p>
<figure class="highlight plaintext"><figcaption><span>asm -f hex "mov eax, 17"</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">把十六进制翻译成汇编语言（类似ghidra里面的那种）</span><br><span class="line">```pwn disasm &quot;31C9F7E1B00551687373776468632F7061682F2F657489E3CD809391B00331D266BAFF0F42CD809231C0B004B301CD8093CD80&quot;</span><br></pre></td></tr></table></figure>

<p>直接用终端把你想给的数据传过去</p>
<figure class="highlight plaintext"><figcaption><span>"\x31 \x80\n" | nc mercury.picoctf.net 16460</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/pwn/" data-id="cm1egdhsu0001q0tw8gejdm4b" data-title="pwn" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf-pwn/" rel="tag">ctf pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-crypto/" rel="tag">ctf crypto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-pwn/" rel="tag">ctf pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-web/" rel="tag">ctf web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ctf-crypto/" style="font-size: 20px;">ctf crypto</a> <a href="/tags/ctf-pwn/" style="font-size: 10px;">ctf pwn</a> <a href="/tags/ctf-web/" style="font-size: 10px;">ctf web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/22/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">BUUCTF刷题记录</a>
          </li>
        
          <li>
            <a href="/2024/09/22/web/">web</a>
          </li>
        
          <li>
            <a href="/2024/09/22/crypto/">crypto</a>
          </li>
        
          <li>
            <a href="/2024/09/22/pwn/">pwn</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Liangyu Chen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>