<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>cly</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="cly">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="cly">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Liangyu Chen">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="cly" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">cly</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-BUUCTF刷题记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:26:31.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">BUUCTF刷题记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://buuoj.cn/challenges">刷题网址</a></p>
<h2 id="1-摩丝"><a href="#1-摩丝" class="headerlink" title="1. 摩丝"></a>1. 摩丝</h2><p>这道题非常简单，对照下面的摩丝表就能很快得到答案。需要特别注意的是，摩丝编码里面只有大写字母，没有小写字母。<br>（图片来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/acmdream/article/details/78329497?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172161266716800222835263%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=172161266716800222835263&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-78329497-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=%E6%91%A9%E4%B8%9D%E5%AF%86%E7%A0%81%E8%A7%84%E5%BE%8B&spm=1018.2226.3001.4187">摩斯密码对照表-CSDN博客</a>）</p>
<h2 id="2-MD5"><a href="#2-MD5" class="headerlink" title="2. MD5"></a>2. MD5</h2><p>使用解密MD5的网站可以轻松解决。<br>解密MD5的相关<a target="_blank" rel="noopener" href="https://www.cmd5.com/">网站</a><br>一个包含了挺多MD5解密的工具集：CTF资源库|CTF工具下载|CTF工具包|CTF工具集合</p>
<h2 id="3-BJDCTF-2nd-cat-flag"><a href="#3-BJDCTF-2nd-cat-flag" class="headerlink" title="3. [BJDCTF 2nd]cat_flag"></a>3. [BJDCTF 2nd]cat_flag</h2><p>打开附件是一个动图，动图由两种小图片组成，每一行有八张图片，很明显是用两种不同的图片来代替0、1。把两种情况都考虑一遍，再用ASCII码表进行解码，即可得到结果。<br>这里记录一下ASCII码表。</p>
<p>（图片来源:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_53030983/article/details/121687624?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172155958516800225532531%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172155958516800225532531&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121687624-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=ascll%E7%A0%81%E8%A1%A8&spm=1018.2226.3001.4187">字母数字-ASCII码表（最详细，最直观）-CSDN博客</a>）</p>
<h2 id="4-GKCTF2020-小学生的密码学"><a href="#4-GKCTF2020-小学生的密码学" class="headerlink" title="4. [GKCTF2020]小学生的密码学"></a>4. [GKCTF2020]小学生的密码学</h2><p>题目如下：<br><code>e(x)=11x+6(mod26)</code><br>密文：<code>welcylk</code><br>（flag为base64形式）<br>这是一个简单的仿射密码。<br>假如有<br>$c&#x3D;a*m+b(mod)n$<br>则有</p>
<p>其中 表示a在模n下的逆。<br>在sagemath中可编写如下代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;welcylk&#x27;</span><br><span class="line">d=pow(11,-1,26)</span><br><span class="line">s=&#x27;&#x27;</span><br><span class="line">for i in a:</span><br><span class="line">    aa=ord(i)-97</span><br><span class="line">    ab=(aa-6)*d</span><br><span class="line">    ac=ab%26</span><br><span class="line">    ad=int(ac)+97</span><br><span class="line">    print(hex(ad))</span><br><span class="line">    s=s+chr(ad)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>再把结果进行base64编码，然后包上flag{}即可得到答案。</p>
<h2 id="5-NewStarCTF-2023-公开赛道-babyrsa"><a href="#5-NewStarCTF-2023-公开赛道-babyrsa" class="headerlink" title="5. [NewStarCTF 2023 公开赛道]babyrsa"></a>5. [NewStarCTF 2023 公开赛道]babyrsa</h2><p>这个rsa中的n是由多个小质数组成的，使用素因数分解的网站可以轻松进行分解。<br>网站：<a target="_blank" rel="noopener" href="http://factordb.com/">http://factordb.com/</a><br>分解后，需要计算phi。这里的phi需要将所有的素数减一后相乘。</p>
<h2 id="6-Dest0g3-520迎新赛-babyRSA"><a href="#6-Dest0g3-520迎新赛-babyRSA" class="headerlink" title="6. [Dest0g3 520迎新赛]babyRSA"></a>6. [Dest0g3 520迎新赛]babyRSA</h2><p>这道题中p和q存在next_prime的关系，所以两个数的差较小，可以遍历这个差值找到答案。我们先对n开平方根，此时得到的结果x应该在p、q之间，且与p、q的差值不大。不断遍历x、x+1、x+2···，判断他们是否可以整除n，即可找到p、q的值。<br>sagemath中的脚本如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n=27272410937497615429184017335437367466288981498585803398561456300019447702001403165885200936510173980380489828828523983388730026101865884520679872671569532101708469344562155718974222196684544003071765625134489632331414011555536130289106822732544904502428727133498239161324625698270381715640332111381465813621908465311076678337695819124178638737015840941223342176563458181918865641701282965455705790456658431641632470787689389714643528968037519265144919465402561959014798324908010947632834281698638848683632113623788303921939908168450492197671761167009855312820364427648296494571794298105543758141065915257674305081267</span><br><span class="line">c=14181751948841206148995320731138166924841307246014981115736748934451763670304308496261846056687977917728671991049712129745906089287169170294259856601300717330153987080212591008738712344004443623518040786009771108879196701679833782022875324499201475522241396314392429412747392203809125245393462952461525539673218721341853515099201642769577031724762640317081252046606564108211626446676911167979492329012381654087618979631924439276786566078856385835786995011067720124277812004808431347148593882791476391944410064371926611180496847010107167486521927340045188960373155894717498700488982910217850877130989318706580155251854</span><br><span class="line">for i in range(1000000000):</span><br><span class="line">    a=n.nth_root(2, truncate_mode=True)</span><br><span class="line">    a=int(a[0])+i</span><br><span class="line">    if n%a==0:</span><br><span class="line">        print(a)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<h2 id="7-NewStarCTF-公开赛赛道-caeser"><a href="#7-NewStarCTF-公开赛赛道-caeser" class="headerlink" title="7. [NewStarCTF 公开赛赛道]caeser"></a>7. [NewStarCTF 公开赛赛道]caeser</h2><p>这道题的密文为<br><code>synt&#123;uvfgbevpny_pvcure_vf_ihyarenoyr&#125;</code><br>根据经验判断，synt的明文应该是flag，计算他们每个字母的ASCII码之间的差，发现相等。对其他字母也减去相同的差值，即可得到结果。</p>
<h2 id="8-NewStarCTF-公开赛赛道-吉奥万·巴蒂斯塔·贝拉索先生的密码"><a href="#8-NewStarCTF-公开赛赛道-吉奥万·巴蒂斯塔·贝拉索先生的密码" class="headerlink" title="8. [NewStarCTF 公开赛赛道]吉奥万·巴蒂斯塔·贝拉索先生的密码"></a>8. [NewStarCTF 公开赛赛道]吉奥万·巴蒂斯塔·贝拉索先生的密码</h2><p>题目为  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pqcq&#123;gteygpttmj_kc_zuokwv_kqb_gtofmssi_mnrrjt&#125;</span><br><span class="line"></span><br><span class="line">Hint: key length is 3</span><br></pre></td></tr></table></figure>
<p>上面一行是密文，下面一行是提示。<br>这是一个维吉尼亚密码，key的长度为3表示上面的字母每3个为一组，每组的解密方式都是相同的。<br>猜测前面四个字母为flag，即可知道分组中每一个字母需要减去的数值，编写C语言代码可以得到结果：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	char *s=&quot;pqcqgteygpttmjkczuokwvkqbgtofmssimnrrjt&quot;;</span><br><span class="line">	for(int j=0;j&lt;strlen(s);j++)&#123;</span><br><span class="line">		int m=(s[j]-97)%26+97;</span><br><span class="line">		while(m&lt;97)&#123;</span><br><span class="line">			m+=26;</span><br><span class="line">		&#125;</span><br><span class="line">		if(j%3==0)&#123;</span><br><span class="line">			m=m-10;</span><br><span class="line">			while(m&lt;97)&#123;</span><br><span class="line">				m+=26;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%c&quot;,m);</span><br><span class="line">		&#125;else if(j%3==1)&#123;</span><br><span class="line">			m=m-5;</span><br><span class="line">			while(m&lt;97)&#123;</span><br><span class="line">				m+=26;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%c&quot;,m);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			m=m-2;</span><br><span class="line">			while(m&lt;97)&#123;</span><br><span class="line">				m+=26;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%c&quot;,m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-NewStarCTF-2023-公开赛道-不止一个pi"><a href="#9-NewStarCTF-2023-公开赛道-不止一个pi" class="headerlink" title="9. [NewStarCTF 2023 公开赛道]不止一个pi"></a>9. [NewStarCTF 2023 公开赛道]不止一个pi</h2><p>这道题目中p、q均已知，主要的问题在于计算phi的值。<br>这里的n是p的三次方乘以q的二次方，而欧拉函数中phi的定义是小于n且与n互质的数的个数。<br>首先考虑phi（p<em>q），我们知道是（p-1）</em>（q-1）。因此在1到p<em>q中有（p-1）</em>（q-1）个数与p<em>q互质。由于n中只有p、q这两个质数，所以在1到p</em>q中也正好有（p-1）<em>（q-1）个数与n互质。<br>由剩余系的概念可以知道在p</em>q+1到2<em>p</em>q中也正好有（p-1）<em>（q-1）个数与n互质，即每p</em>q个数中有（p-1）<em>（q-1）个数与n互质。而n中总共有p</em>p<em>q个p</em>q，所以phi（n）的值就是p<em>p</em>q<em>（p-1）</em>（q-1）。<br>使用该phi计算d的值，再计算明文，就能得到结果。</p>
<h2 id="10-一眼就解密"><a href="#10-一眼就解密" class="headerlink" title="10. 一眼就解密"></a>10. 一眼就解密</h2><p>这道题就是一道base64的解密题，这里记录一个解密的在线网站<br>Base64 在线编码解码 | Base64 加密解密 - Base64.us</p>
<h2 id="11-NewStarCTF-2023-公开赛道-滴啤"><a href="#11-NewStarCTF-2023-公开赛道-滴啤" class="headerlink" title="11. [NewStarCTF 2023 公开赛道]滴啤"></a>11. [NewStarCTF 2023 公开赛道]滴啤</h2><p>这道rsa的题目中给了dp、e、n和c。<br>因为</p>
<p>所以有</p>
<p>把（2）式代入（1）式，两边再同时对（p-1）取模，即可得到</p>
<p>所以有</p>
<p>那么我们就可以尝试计算出dp*e-1的值，再对其进行分解，以尝试获取到p-1的值。<br>这一题中，分解后可知该数共有8个素因数，其因数的总数量并不多，完全可以进行遍历。由于p的位数约为512位，而素因数有一个近400位的素数，所以它一定是p-1的一个因数（反证法易证）。那么我们遍历的数量就可以进一步减少了。<br>使用sagemath进行遍历的代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p2=2*13576168482904074972916434606484064894094750779290370955123911937153145555527439626414947690638030717530975726269496353</span><br><span class="line">m=[3,3,3,7,251,133201,52499805387917,2237058624000923]</span><br><span class="line">n=93172788492926438327710592564562854206438712390394636149385608321800134934361353794206624031396988124455847768883785503795521389178814791213054124361007887496351504099772757164211666778414800698976335767027868761735533195880182982358937211282541379697714874313863354097646233575265223978310932841461535936931</span><br><span class="line">for i in range(256):</span><br><span class="line">    x=bin(i)[2:].zfill(8)</span><br><span class="line">    p=p2</span><br><span class="line">    for j in range(len(x)):</span><br><span class="line">        if int(x[j])==1:</span><br><span class="line">            p=p*int(x[j])*int(m[j])</span><br><span class="line">    p=p+1</span><br><span class="line">    if n%p==0:</span><br><span class="line">        print(p)</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<h2 id="12-NewStarCTF-2023-公开赛道-babyencoding"><a href="#12-NewStarCTF-2023-公开赛道-babyencoding" class="headerlink" title="12. [NewStarCTF 2023 公开赛道]babyencoding"></a>12. [NewStarCTF 2023 公开赛道]babyencoding</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">part 1 of flag: ZmxhZ3tkYXp6bGluZ19lbmNvZGluZyM0ZTBhZDQ=</span><br><span class="line">part 2 of flag: MYYGGYJQHBSDCZJRMQYGMMJQMMYGGN3BMZSTIMRSMZSWCNY=</span><br><span class="line">part 3 of flag: =8S4U,3DR8SDY,C`S-F5F-C(S,S&lt;R-C`Q9F8S87T`</span><br></pre></td></tr></table></figure>
<p>这道题就是三种不同的编码方式。<br>第一部分中有大小写字母和数字，最后还有一个等号，是base64编码，使用网站可以解决（网站见“一眼就解密”模块）。<br>第二部分只有大写字母和数字，是base32编码，我用sagemath写了个脚本进行解码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;MYYGGYJQHBSDCZJRMQYGMMJQMMYGGN3BMZSTIMRSMZSWCNY&#x27;</span><br><span class="line">c=[]</span><br><span class="line">for i in a:</span><br><span class="line">    m=ord(i)</span><br><span class="line">    if m&gt;0x40:</span><br><span class="line">        c.append(int(m-ord(&#x27;A&#x27;)))</span><br><span class="line">    else:</span><br><span class="line">        c.append(int(m-ord(&#x27;2&#x27;))+26)</span><br><span class="line">s=&#x27;&#x27;</span><br><span class="line">for i in c:</span><br><span class="line">    a=bin(i)[2:].zfill(5)</span><br><span class="line">    s=s+a</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>这个脚本得到的结果为二进制的结果，最后需要进行补零，使其位数为8的倍数。<br>第三部分的编码方式为UUencode编码，可以利用在线网站进行解密。<br>可使用网站：在线工具 - Bugku CTF</p>
<h2 id="13-NewStarCTF-2023-公开赛道-babyxor"><a href="#13-NewStarCTF-2023-公开赛道-babyxor" class="headerlink" title="13. [NewStarCTF 2023 公开赛道]babyxor"></a>13. [NewStarCTF 2023 公开赛道]babyxor</h2><p>这道题目把flag中的每一个字符与一个未知的key异或之后进行了输出，因此我们需要解出这个key的值。直接猜测flag中的前四个字符为“flag”，把这四个字符与已知的输出值的前三十二位进行一次异或，发现得到的结果是重复的0x8f，因此key的值就是0x8f。</p>
<h2 id="14-NewStarCTF-公开赛赛道-eazyxor"><a href="#14-NewStarCTF-公开赛赛道-eazyxor" class="headerlink" title="14. [NewStarCTF 公开赛赛道]eazyxor"></a>14. [NewStarCTF 公开赛赛道]eazyxor</h2><p>这道题目和13里面一模一样，这里就把sagemath计算key的脚本放一下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=0x9b919c9a</span><br><span class="line">b=0x666c6167</span><br><span class="line">def xor(p,q):</span><br><span class="line">    p=int(p)</span><br><span class="line">    q=int(q)</span><br><span class="line">    return p&amp;(~q)|(~p)&amp;q</span><br><span class="line">c=xor(a,b)</span><br><span class="line">print(hex(c))</span><br></pre></td></tr></table></figure>
<p>（最近发现在sagemath中^^可以表示异或，所以其实并不需要写一个异或的函数）</p>
<h2 id="15-NewStarCTF-2023-公开赛道-Affine"><a href="#15-NewStarCTF-2023-公开赛道-Affine" class="headerlink" title="15. [NewStarCTF 2023 公开赛道]Affine"></a>15. [NewStarCTF 2023 公开赛道]Affine</h2><p>这也是一道仿射变换的题目，需要求出key的值（key是一个包含两个元素的列表）。其仿射变换的公式为：</p>
<p>我们只需要知道flag中两个的两个字母和他们对应的output的值，就能求解出key的值，具体的操作如下：<br>假设已知x、y，未知数为a、b，有</p>
<p>联立上面的两个式子，用（1）式减去（2）式，得到</p>
<p>则可计算出a的值为</p>
<p>再把a的值代入（1）式或（2）式中，即可得到b的值为</p>
<p>通过上面的分析，可以用sagemath写出解密的代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">f1=0x66</span><br><span class="line">f2=0x61</span><br><span class="line">b1=0xdd</span><br><span class="line">b2=0x88</span><br><span class="line">b=b1-b2</span><br><span class="line">f=f1-f2</span><br><span class="line">x=pow(f,-1,256)</span><br><span class="line">a0=(b*x)%256</span><br><span class="line">a1=(b1-f1*a0)%256</span><br><span class="line">n=pow(a0,-1,256)</span><br><span class="line">h=&#x27;dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064&#x27;</span><br><span class="line">c=&#x27;&#x27;</span><br><span class="line">for i in range(len(h)//2):</span><br><span class="line">    x=&#x27;0x&#x27;+h[2*i]+h[2*i+1]</span><br><span class="line">    b=int(x,16)</span><br><span class="line">    m=((b-a1)*n)%256</span><br><span class="line">    c=c+chr(m)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<p>在“flag”中使用差值计算出f时，结果可能不会和256互质，比如“f”和“l”这两个字符，所以我在选择明文时选择了“f”和“a”这两个字符。</p>
<h2 id="16-NewStarCTF-2023-公开赛道-halfcandecode"><a href="#16-NewStarCTF-2023-公开赛道-halfcandecode" class="headerlink" title="16. [NewStarCTF 2023 公开赛道]halfcandecode"></a>16. [NewStarCTF 2023 公开赛道]halfcandecode</h2><p>这道题是上面的第二题和第六题的结合体，需要用到rsa和MD5。<br>rsa的部分也可以使用第五题中的网站进行分解。需要注意的是出题人在前半部分flag的后面加入了一些乱码，在解密的时候需要删除。MD5的部分则只要使用第六题的网站就能解决。其中有些MD5的值需要充钱获取，可以使用网站MD5免费在线解密破解_MD5在线加密-SOMD5破解。</p>
<h2 id="17-NewStarCTF-2023-公开赛道-Rotate-Xor"><a href="#17-NewStarCTF-2023-公开赛道-Rotate-Xor" class="headerlink" title="17. [NewStarCTF 2023 公开赛道]Rotate Xor"></a>17. [NewStarCTF 2023 公开赛道]Rotate Xor</h2><p>这道题中k1的加密方法为进行十二轮的循环左移和异或操作，其中每一轮的加密方法可由下面的公式表示，其中roundrotateleft函数为给出的循环左移函数，这里表示循环左移三位。</p>
<p>由此写出每一轮的解密方法， 再用此方法对已知的加密后的k1的密文进行十二轮的解密，就能得到最后的答案。解密方法可用下面的公式表示，其中roundrotateright函数需要自己编写。</p>
<p>用sagemath编写下面的代码得到k1的值：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enc_k1 = 7318833940520128665</span><br><span class="line">k2 = 9982833494309156947</span><br><span class="line">key=enc_k1</span><br><span class="line">def round_rotate_right(num, step):</span><br><span class="line">    return ((num) &gt;&gt; step | num &lt;&lt; (64-step))&amp;0xffffffffffffffff</span><br><span class="line">for _ in range(12):</span><br><span class="line">    key=xor(key,k2)</span><br><span class="line">    key=round_rotate_right(key,3)</span><br><span class="line">print(hex(key))</span><br></pre></td></tr></table></figure>
<p>代码中的xor函数在第十四题的脚本中进行了定义。<br>得到k1后，发现k1的长度与给出的密文ciphertext的长度是不一致的，因此需要知道题目中加密用到的函数xor的用法。这个是从pwn库中引入的函数，我猜测是像分组密码一样分组进行异或，就用最前面的四个字符尝试了一下，发现得到的确实是“flag”。所以按照分组密码的加密方式对密文进行了异或，就得到了答案。</p>
<h2 id="18-NewStarCTF-2023-公开赛道-babyNTRU"><a href="#18-NewStarCTF-2023-公开赛道-babyNTRU" class="headerlink" title="18. [NewStarCTF 2023 公开赛道]babyNTRU"></a>18. [NewStarCTF 2023 公开赛道]babyNTRU</h2><p>这是一道格密码的题目，需要求解的公式为：</p>
<p>其中e、h、q已知，x和m未知。我们可以把公式改写为：</p>
<p>由此可以写出矩阵计算公式：</p>
<p>对其中3×3的矩阵使用LLL算法，就能得到结果，写出的sagemath代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h=8916452722821418463248726825721257021744194286874706915832444631771596616116491775091473142798867278598586482678387668986764461265131119164500473719939894343163496325556340181429675937641495981353857724627081847304246987074303722642172988864138967404024201246050387152854001746763104417773214408906879366958729744259612777257542351501592019483745621824894790096639205771421560295175633152877667720038396154571697861326821483170835238092879747297506606983322890706220824261581533324824858599082611886026668788577757970984892292609271082176311433507931993672945925883985629311514143607457603297458439759594085898425992</span><br><span class="line">q=31985842636498685945330905726539498901443694955736332073639744466389039373143618920511122288844282849407290205804991634167816417468703459229138891348115191921395278336695684210437130681337971686008048054340499654721317721241239990701099685207253476642931586563363638141636011941268962999641130263828151538489139254625099330199557503153680089387538863574480134898211311252227463870838947777479309928195791241005127445821671684607237706849308372923372795573732000365072815112119533702614620325238183899266147682193892866330678076925199674554569018103164228278742151778832319406135513140669049734660019551179692615505961</span><br><span class="line">e=20041713613876382007969284056698149007154248857420752520496829246324512197188211029665990713599667984019715503486507126224558092176392282486689347953069815123212779090783909545244160318938357529307482025697769394114967028564546355310883670462197528011181768588878447856875173263800885048676190978206851268887445527785387532167370943745180538168965461612097037041570912365648125449804109299630958840398397721916860876687808474004391843869813396858468730877627733234832744328768443830669469345926766882446378765847334421595034470639171397587395341977453536859946410431252287203312913117023084978959318406160721042580688</span><br><span class="line">mat=[[e,0,1],[h,1,0],[q,0,0]]</span><br><span class="line">M = Matrix(QQ,mat)</span><br><span class="line">lll=M.LLL()</span><br><span class="line">print((lll[0]))</span><br></pre></td></tr></table></figure>
<p>其中打印出来的结果即为上面的公式中等号右边的向量。</p>
<h2 id="19-GKCTF2020-babycrypto"><a href="#19-GKCTF2020-babycrypto" class="headerlink" title="19. [GKCTF2020]babycrypto"></a>19. [GKCTF2020]babycrypto</h2><p>这道题中的n可以直接使用第五题中的网站进行分解。</p>
<h2 id="20-NewStarCTF-2023-公开赛道-Smart"><a href="#20-NewStarCTF-2023-公开赛道-Smart" class="headerlink" title="20. [NewStarCTF 2023 公开赛道]Smart"></a>20. [NewStarCTF 2023 公开赛道]Smart</h2><p>这是一道ecc的题目，根据提示可以使用smart attack的方法解题。使用sagemath可以编写出下面的代码：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">p = 75206427479775622966537995406541077245842499523456803092204668034148875719001</span><br><span class="line">a = 40399280641537685263236367744605671534251002649301968428998107181223348036480</span><br><span class="line">b = 34830673418515139976377184302022321848201537906033092355749226925568830384464</span><br><span class="line">E = EllipticCurve(GF(p),[a,b])</span><br><span class="line">P=E(63199291976729017585116731422181573663076311513240158412108878460234764025898,11977959928854309700611217102917186587242105343137383979364679606977824228558)</span><br><span class="line">Q=E(75017275378438543246214954287362349176908042127439117734318700769768512624429,39521483276009738115474714281626894361123804837783117725653243818498259351984)</span><br><span class="line">def SmartAttack(P,Q,p):</span><br><span class="line">    E = P.curve()</span><br><span class="line">    Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ])</span><br><span class="line">    P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True)</span><br><span class="line">    for P_Qp in P_Qps:</span><br><span class="line">        if GF(p)(P_Qp.xy()[1]) == P.xy()[1]:</span><br><span class="line">            break</span><br><span class="line">    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True)</span><br><span class="line">    for Q_Qp in Q_Qps:</span><br><span class="line">        if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]:</span><br><span class="line">            break</span><br><span class="line">    p_times_P = p*P_Qp</span><br><span class="line">    p_times_Q = p*Q_Qp</span><br><span class="line">    x_P,y_P = p_times_P.xy()</span><br><span class="line">    x_Q,y_Q = p_times_Q.xy()</span><br><span class="line">    phi_P = -(x_P/y_P)</span><br><span class="line">    phi_Q = -(x_Q/y_Q)</span><br><span class="line">    k = phi_Q/phi_P</span><br><span class="line">    return ZZ(k)</span><br><span class="line">r = SmartAttack(P, Q, p)</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure>
<p>（函数脚本来自Lazzaro @ 分类 | Lazzaro）</p>
<h2 id="21-V-N2020-公开赛-Backtrace"><a href="#21-V-N2020-公开赛-Backtrace" class="headerlink" title="21. [V&amp;N2020 公开赛]Backtrace"></a>21. [V&amp;N2020 公开赛]Backtrace</h2><p>这是一道向前还原梅森旋转算法产生的随机数的题目，可以使用python3中已有的库中的函数进行解密，脚本如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from extend_mt19937_predictor import ExtendMT19937Predictor</span><br><span class="line">predictor = ExtendMT19937Predictor()</span><br><span class="line">x=[1954915070, 880079313, 360906530, 1379349539, 2990290602, 2779090715, 1195886637, 26260733, 1583365168, 3665368407, 32035604, 23154243, 4175855420, 4087729539, 4061778341, 1842490363, 24026296, 506531036, 3305517750, 2480717543, 3912881681, 2674873504, 3352869450, 3592419601, 3036323492, 1082383946, 3598180449, 547795339, 549590551, 3028169916, 2073824705, 1647033805, 1120414536, 3923037909, 3779751646, 2143420925, 3908526958, 3918342792, 3262098248, 3804166870, 1736455411, 2417662325, 3135605338, 428676667, 3664109984, 2807365630, 592564266, 1511929376, 3720241883, 3519131811, 88062728, 2452008344, 1376675709, 666109304, 4110417201, 4220702851, 3778634814, 4211738848, 715753516, 2658852621, 2979894716, 1247212269, 4178194405, 1781101726, 1041419594, 1709310125, 3813614389, 458927554, 3764695336, 2441752341, 1253881549, 1225143052, 3557368845, 3838600385, 704097569, 1795077589, 1307245977, 1717115299, 983409487, 2129778243, 3432359775, 1630272089, 1044229449, 1934797629, 256992360, 739187055, 2003823253, 2520758703, 4188045315, 1831601825, 1613890879, 43212525, 286036422, 730199546, 2111917986, 2296406771, 1523494866, 22453673, 1713781269, 289582587, 1190283387, 215790012, 3341532120, 4143468851, 3911058947, 1744160183, 1737482991, 995300206, 1209025742, 2548392860, 2112397256, 2328723112, 3252904928, 2986221228, 920151702, 2869410691, 297356863, 1113160659, 1723226249, 91041567, 1364664100, 1603980497, 1950077086, 2463918675, 1270243131, 2690292580, 1422349327, 862261952, 967425382, 2141373124, 784240543, 3431833360, 490754262, 3848551199, 3374708506, 1730158500, 1679948052, 1037254337, 1542986195, 3179769778, 525752391, 2138533768, 4060094504, 3749351453, 1653628056, 3891244202, 587949751, 2117666819, 3989217878, 236634714, 347834593, 36437255, 857428838, 802901512, 2150725842, 1293111161, 149116333, 1195588424, 2803507599, 1721551167, 3936542960, 3957883800, 126595404, 871451152, 565527716, 1622812264, 2809311587, 3016835340, 162902761, 4206750381, 3921119290, 1504723782, 3293690462, 3083506005, 811746919, 3455687374, 767562328, 3777952933, 2172820246, 2605716515, 1756246148, 2243128034, 1344314147, 3763482539, 2562146979, 3163206461, 3618311150, 1189035477, 7231879, 815006324, 195187971, 1578170963, 1078365572, 463220548, 92395730, 2138595439, 1322999823, 2469535746, 2749391749, 3433099223, 3983509306, 2111542870, 3745476971, 919481220, 1230712391, 3811227914, 1736577469, 2419466842, 1541026951, 398886450, 1510256083, 3548576351, 1983859038, 938962757, 172522539, 1019282319, 332128756, 3299336175, 2841132609, 2197477198, 3371426587, 1442166578, 3238850747, 1747647226, 2283411662, 1204012944, 3295272849, 1586724848, 4022995561, 3742366393, 79843478, 2109666146, 2406199134, 420281144, 1098025843, 519159390, 536903419, 2387574872, 585556144, 4037282670, 1816756967, 3987753062, 1495823125, 1010457539, 720442860, 8816820, 1812416478, 3356964625, 158012176, 902760599, 1749660162, 4160594328, 393212714, 877871013, 3616848204, 4126377209, 4259811533, 1989917399, 582786867, 1093424901, 1333179279, 1800875923, 1598085790, 627659277, 32688263, 2222145572, 938619663, 1467384991, 2777852620, 4233202126, 295416244, 3515893229, 572401093, 2526938242, 3851968999, 3599541582, 91522073, 1825233519, 2339315265, 4123218487, 2650729621, 287304953, 1423724344, 2908364142, 2748769808, 3418694754, 3917094690, 2646486860, 2858627000, 3305171165, 3401244148, 2180778517, 1737578689, 1322497258, 4144511518, 1856725795, 1477318062, 911248289, 1535195390, 3144994767, 4101205532, 3808591560, 2213985378, 3252595633, 2337367507, 534460335, 2441670955, 1990989375, 3808438725, 3804201721, 3999376545, 1014481854, 2090372701, 2927739146, 1300032996, 534772267, 3335311855, 664080148, 3129094809, 1075386087, 3651483413, 3363859879, 3226823199, 2964465151, 3285786367, 2581149182, 262038551, 2762741963, 922363707, 1260642832, 1183500610, 2803108134, 3592591385, 1484954269, 161632434, 3860482129, 3556119993, 1784107097, 1861391286, 3891693742, 1469562815, 4052616817, 1735123567, 3981493161, 1172433134, 4142248853, 1586222290, 3539037789, 1427799338, 1876694928, 1200583260, 1752440053, 291416352, 2106928780, 936954012, 197470641, 2337076377, 1421119809, 3135686533, 398635959, 4172800048, 399974723, 287928291, 529512170, 1921498685, 567654083, 1812953083, 4068864497, 2881211664, 2429816180, 4084286231, 1928525086, 3886022768, 1443924813, 1820391016, 3624477251, 1452182198, 3501771914, 3307175554, 1233333926, 4242916900, 1054132061, 1725357747, 4125133480, 2860075310, 3091839411, 3820381997, 1335282777, 2927671741, 2241788945, 3488880264, 2095731302, 1214404049, 592041371, 3490153501, 238412730, 85745765, 1498653208, 288707861, 2868112869, 491758034, 375898933, 529291211, 1526086068, 1434399655, 758215890, 1276881381, 3266726291, 3413372766, 3488548535, 145011592, 45063434, 3505575389, 1780705822, 2662969703, 856437165, 3634545960, 2660427148, 977850868, 1582014613, 4189751436, 866116713, 1216606975, 420500706, 2031559891, 1026985902, 3713148233, 494872740, 590852345, 1318692699, 1051590564, 365025448, 210057222, 4081233470, 836354250, 2395488189, 3089620058, 3371189485, 2492384566, 317404020, 3448768638, 1914822123, 2007144480, 3375740426, 4089530814, 1711142699, 1845862399, 2063343799, 3364295943, 3659690944, 546211494, 1414275727, 3044491383, 3050919928, 3390640243, 3843994607, 4283790197, 1589762674, 2433218003, 3728021067, 1131986129, 2737833357, 2800289380, 2753380618, 900710707, 4131195838, 2668161437, 940253312, 4137815270, 939482424, 1748091577, 3546489510, 3421396386, 4148510311, 4165939267, 726262463, 3050178325, 3177146914, 3563060942, 1534352901, 3355774700, 3917022484, 2589474555, 3331795641, 1102689414, 3183908672, 1002812809, 152821999, 2292133358, 1383462496, 1723940974, 1109447662, 3735817236, 2653647203, 4026819614, 1197259783, 2243347947, 4231464616, 2510151911, 4222963505, 1139252638, 756514223, 3417745074, 1468496068, 3161226317, 1246424725, 1872920987, 2647633430, 3258968525, 253034280, 1645087047, 3247041431, 1054772676, 379436873, 2600620229, 2594042244, 661729386, 1665438570, 1017686809, 233096083, 845378242, 3372582854, 410404381, 2007910443, 4292394895, 3237528904, 3176696608, 3307483127, 1197245101, 162556298, 2316117728, 1197610943, 2268702243, 3342707155, 3853282575, 916356664, 679322020, 3607041524, 437255662, 1779501694, 2192606690, 3849753853, 2382746933, 3266572424, 1897113113, 3929458586, 2295574218, 3398667663, 489651240, 554749675, 2685580250, 271948130, 3301333969, 2402822376, 2006322914, 3300613934, 2720365129, 1219841771, 253738666, 4062523722, 908057314, 734682735, 3993608743, 2005954106, 4196754468, 2180968904, 2927088293, 3201719969, 3258216746, 1697012102, 451497250, 4140321978, 1626314925, 2634645740, 2650768687, 4037717892, 3530817306, 3154301628, 607258212, 1138057824, 1483931056, 1779526200, 772778910, 3269411312, 2168622217, 3392463299, 2129731229, 663170712, 3481534219, 3813779502, 4003014679, 1417316990, 3758399028, 3050577451, 4287031625, 4219536484, 3110762846, 3162149172, 2925735942, 3222005405, 3901793171, 2438213679, 2761390133, 2868086632, 2262419687, 2548717542, 662411455, 2628823526, 1947247956, 192432795, 356145859, 1388455292, 1337879771, 1318475009, 4194024566, 3055182968, 3818161981, 4122245354, 1163215145, 4064532043, 1427071812, 3338509721, 996878503, 4035314277, 4009039326, 916055062, 3817247526, 1111659075, 2245077089, 1027546064, 3342483659, 1793234141, 1571978271, 1560889567, 3201761295, 2525084128, 1111852520, 147467714, 3308281891, 2593100275, 1890216029, 2245520263, 3905179223, 4166586105, 4058069805, 2234254266, 897808812, 1276352683, 4089183900, 1496670572, 2979089043, 1110628736, 3320051082, 3285541627, 4026820048, 414845486, 2742275697, 2611076257, 2183923292, 715603118, 3655611426, 1042307613, 1538032337, 3770267700, 2701884650, 807662565, 1412021992, 2190384229, 636193740, 2262474952, 1037800098, 2251081302, 2110190277, 1818325893, 357637012, 3220347372, 3779111771, 2794951662, 2053531638, 3865719745, 1117551032, 2005076639, 3052789596, 1850346070, 3250668743, 3748374363, 3366024365, 1797731176, 4167453426, 3273801260, 270498944, 3409183492, 2435803649, 4214667811, 3331238798, 2204118424, 124311085, 821069678, 402529460, 4241047514, 3597966193, 2484307360, 745429577, 1575021475, 2880532249, 1653073618, 2042789973, 1988689809, 2986312451, 998861281, 3049071914, 3105090905, 1948439372, 1812644387, 2463127929, 4111481103, 986806020, 1163777124, 2780762085, 2078725375, 2407568318, 3342714967, 2772408458, 490512106, 143570762, 1232716574, 519717220, 158618961, 1436523816, 4216701765, 307191458, 2912138910, 3468252635, 386069354, 1634782909, 392302934, 781725611, 3497023560, 4225924396, 1795951064, 3928854990, 1539311975, 3391120265, 232461937, 4184782267, 1731411767, 1647711068, 2103390822, 3545452835, 3898032707, 2174552994, 1311574900, 822414312, 1839460614, 1762983458, 2140522204, 417114171, 2942594202, 3153277613, 706508900, 1240369844, 2262617676, 2812407518, 1840197328, 1824634385, 859165172, 1576784364, 585466601, 1765607687, 3423031247, 1284381057, 3382474784, 3123254074, 2194861604, 495637126, 2802357617, 1226312598, 1818564904, 2754819901, 3465896582, 414214415, 1786854851, 3480143070, 1969087474, 2384690047, 764711574, 888969866, 291549264, 1623430983, 1065342949, 3771290713, 2607894650, 2849509696, 633784811, 592845780, 3632194205, 889199132, 4102077198, 29170934, 34456705, 2613055456, 1078880049, 1106268704, 22020620, 2586845047, 2925005739, 1854339682, 1649915319, 4071303129, 4140750565, 897249960, 1279599439, 1549858622, 2530236320, 357028938, 187680170, 2825532344, 3474432045, 1459157318, 1078630130, 522441272, 1021727782, 756127542, 670068161, 1933389429, 2126666549, 3233405034, 691338491, 617019618, 1572960014, 2476894878, 3114330689, 190756003, 343951393, 254882512, 3232970324, 1278199314, 136867483, 1288546656, 3526700531, 2819009094, 3204612611, 1139498748, 3875800906, 255305389, 2504064025, 3125108091, 2176350989, 2469637779, 3339575355, 2999412374, 1282126909, 1551339993, 3573997525, 3812552026, 2137007302, 3302434775, 1777310304, 2053104074, 2328784509, 2188979055, 1553054099, 857550765, 3714986904, 21124773, 1651956692, 220434238, 483698922, 1770276048, 3987677675, 2078271890, 4127930299, 913495199, 1552004068, 318877141, 3540501698, 1999579835, 935784539, 390615388, 2903539749, 3837464977, 3922761762, 108363706, 767261731, 592768246, 100601999, 767766613, 1170959252, 723154566, 2277226093, 1249730541, 4207253124, 3412009687, 2427450601, 3312907551, 1823542002, 2660960835, 3032107443, 3010173489, 3100247405, 1939956123, 630159399, 2588902313, 2901045261, 3788987361, 802990870, 333237497, 1240204630, 2845468633, 3360840386, 3763275014, 2632404055, 3815462044, 3818227716, 1049832368, 54028478, 758732492, 1815724078, 1246513687, 2374051260, 807659196, 3751209486, 3409043148, 559342443, 2430700654, 398612276, 241887832, 1939697736, 2288135888, 655726394, 1451329969, 1119873489, 799074425, 2253637924, 2053706296, 1548769628, 3867902836, 1247111501, 1004835651, 2850968664, 653021090, 1292848338, 154967348, 4194736783, 3102822469, 2261232318, 1657165783, 182571243, 2866887396, 4290974852, 2261061037, 3629684605, 2482236569, 1916603941, 3382603226, 999768427, 3171175558, 1709542380, 2086924233, 3964979595, 85833410, 1122206428, 1432694206, 4230090721, 2632877999, 834731838, 2344308939, 2399519878, 4086951271, 2681850703, 3113324115, 2045734372, 1980879301, 2869222671, 2270508944, 3549736736, 3871179085, 1302255582, 4224050094, 2185529812, 165196590, 2581134223, 579189627, 4045953032, 2910507974, 633486844, 4092863379, 279952867, 654229974, 3590879432, 3494667849, 3762736646, 4057616614, 1378958651, 3737744634, 2799387186, 127072071, 1886119253, 3542028713, 3083942542]</span><br><span class="line">for i in range(624):</span><br><span class="line">    predictor.setrandbits(x[i],32)</span><br><span class="line">a= [predictor.backtrack_getrandbits(32) for _ in range(628)]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>（函数脚本来自 Lazzaro @ 分类 | Lazzaro）<br>打印出来的a中最后四个数即为所需的向前还原的随机数。按提示即可得到flag。<br>本题中，由于给的output中的随机数没有以列表的形式给出，所以我用python3写了一个读取整数的脚本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">with open(&#x27;output.txt&#x27;, &#x27;r&#x27;) as file:</span><br><span class="line">    content = file.read()</span><br><span class="line">numbers = re.findall(r&#x27;\d+&#x27;, content)</span><br><span class="line">numbers = [int(num) for num in numbers]</span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure>
<h2 id="22-NewStarCTF-公开赛赛道-Affine"><a href="#22-NewStarCTF-公开赛赛道-Affine" class="headerlink" title="22. [NewStarCTF 公开赛赛道]Affine"></a>22. [NewStarCTF 公开赛赛道]Affine</h2><p>这道题和第十五题一模一样，这次还提示了要使用flag的格式。</p>
<h2 id="23-变异凯撒"><a href="#23-变异凯撒" class="headerlink" title="23. 变异凯撒"></a>23. 变异凯撒</h2><p>这道题的题目为：<br>加密密文：<code>afZ_r9VYfScOeO_UL^RWUc</code><br>格式：<code>flag&#123; &#125;</code><br>说是变异凯撒，那肯定是和凯撒密码有关。一开始我以为密文中去掉下划线之后剩下的部分进行凯撒密码的变换之后可以得到三个单词，最后再包上flag{}进行提交。结果穷举了半天都没有找到什么合适的结果。<br>后来想起来其他题目好像都是说包上flag{}进行提交，而这个只说了格式是flag{}，我猜测是一个已知明文攻击的题目，就用前四个密文字符的ASCII码减去了flag对应的ASCII码，这才找到了这道题目的加密方法。用sagemath写的解密脚本如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;afZ_r9VYfScOeO_UL^RWUc&#x27;</span><br><span class="line">b=&#x27;&#x27;</span><br><span class="line">for i in range(len(a)):</span><br><span class="line">   b=b+chr(ord(a[i])+5+i)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<h2 id="24-Quoted-printable"><a href="#24-Quoted-printable" class="headerlink" title="24. Quoted-printable"></a>24. Quoted-printable</h2><p>Quoted-printable_ 引用可打印-CSDN博客这篇博客中有详细的介绍，具体的编码转换可以使用下面的网址：Quoted-printable编码|Quoted-printable解码|Quoted-printable编码原26理介绍–查错网</p>
<h2 id="25-篱笆墙的影子"><a href="#25-篱笆墙的影子" class="headerlink" title="25. 篱笆墙的影子"></a>25. 篱笆墙的影子</h2><p>题目为<code>felhaagv&#123;ewtehtehfilnakgw&#125;</code><br>根据提示是栅栏密码，找到{的位置，发现是第9位，前面单数位的字符刚好组成“flag”，很明显栏数为2，简单用sagemath写个脚本解密：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;felhaagv&#123;ewtehtehfilnakgw&#125;&#x27;</span><br><span class="line">b=&#x27;&#x27;</span><br><span class="line">for i in range(len(a)//2):</span><br><span class="line">    b=b+a[2*i]</span><br><span class="line">for i in range(len(a)//2):</span><br><span class="line">    b=b+a[2*i+1]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<h2 id="26-Rabbit"><a href="#26-Rabbit" class="headerlink" title="26. Rabbit"></a>26. Rabbit</h2><p>具体的编码方法可以参考BUUCTF Rabbit 1-CSDN博客这篇博客，其中用到的在线解密工具为Rabbit加密-Rabbit解密-在线Rabbit加密解密工具</p>
<h2 id="27-丢失的MD5"><a href="#27-丢失的MD5" class="headerlink" title="27. 丢失的MD5"></a>27. 丢失的MD5</h2><p>打开附件发现一个python代码，尝试运行，发现有报错。把报错的地方修改后即可运行得到正确答案，修改后的代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import hashlib   </span><br><span class="line">for i in range(32,127):</span><br><span class="line">    for j in range(32,127):</span><br><span class="line">        for k in range(32,127):</span><br><span class="line">            m=hashlib.md5()</span><br><span class="line">            m.update((&#x27;TASC&#x27;+chr(i)+&#x27;O3RJMV&#x27;+chr(j)+&#x27;WDJKX&#x27;+chr(k)+&#x27;ZM&#x27;).encode(&#x27;utf-8&#x27;))</span><br><span class="line">            des=m.hexdigest()</span><br><span class="line">            if &#x27;e9032&#x27; in des and &#x27;da&#x27; in des and &#x27;911513&#x27; in des:</span><br><span class="line">                print(des)</span><br></pre></td></tr></table></figure>
<h2 id="28-GKCTF2020-汉字的秘密"><a href="#28-GKCTF2020-汉字的秘密" class="headerlink" title="28. [GKCTF2020]汉字的秘密"></a>28. [GKCTF2020]汉字的秘密</h2><p>这道题中用汉字的笔划出头的数量来表示数字。<br>比如说“口”，没有出头，表示0，“由”有一个出头的笔划，表示1。把题目中涉及的所有汉字的笔划数计算出来，然后可以用sagemath写出下面的脚本解密：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=&#x27;田口由中人工大土士王夫井羊壮&#x27;</span><br><span class="line">b=&#x27;00123455567899&#x27;</span><br><span class="line">c=&#x27;王壮夫工王中王夫由由井井人夫中夫夫井王土土夫由土夫井中士夫王工王人土由由口夫&#x27;</span><br><span class="line">s = &#x27;&#x27;</span><br><span class="line">for i in c:</span><br><span class="line">    s=s+b[a.index(i)]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>这样能得到一串数字‘69746267118837277865571578257646351107’，然后看给的文档里面汉字的组合情况，发现有些是两个汉字连在一起，有些是三个汉字连在一起，感觉像是每个字符的ASCII编码。根据提示将这些数值与flag中的字符的ASCII进行对比，发现这道题的加密方式与第二十三题变异凯撒差不多，于是可以用sagemath写出解密代码如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m=&#x27;69746267118837277865571578257646351107&#x27;</span><br><span class="line">s=&#x27;&#x27;</span><br><span class="line">for i in range(len(m)//2-2):</span><br><span class="line">    if i &lt;4:</span><br><span class="line">        x=int(m[2*i])*10+int(m[2*i+1])+i+1</span><br><span class="line">        s=s+chr(x)</span><br><span class="line">    elif i ==4:</span><br><span class="line">        x=100+int(m[2*i+1])*10+int(m[2*i+2])+i+1</span><br><span class="line">        s=s+chr(x)</span><br><span class="line">    else:</span><br><span class="line">        x=int(m[2*i+1])*10+int(m[2*i+2])+i+1</span><br><span class="line">        s=s+chr(x)</span><br><span class="line">s=s+chr(107+len(m)//2-1)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>最后得到的结果是大写的字母，按提示需要改成小写的字母进行提交。</p>
<h2 id="29-NewStarCTF-2023-公开赛道-Rabin’s-RSA"><a href="#29-NewStarCTF-2023-公开赛道-Rabin’s-RSA" class="headerlink" title="29. [NewStarCTF 2023 公开赛道]Rabin’s RSA"></a>29. [NewStarCTF 2023 公开赛道]Rabin’s RSA</h2><p>在rsa的rabin加密中，e取2，需要知道p、q的值才能解密，用sagemath写的具体的解密脚本如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">p=13934102561950901579</span><br><span class="line">q=14450452739004884887</span><br><span class="line">n=201354090531918389422241515534761536573 </span><br><span class="line">c=20442989381348880630046435751193745753 </span><br><span class="line">inv_p=int(pow(p,-1,q))</span><br><span class="line">inv_q=int(pow(q,-1,p))</span><br><span class="line">mp=int(pow(c,(p+1)//4,p))</span><br><span class="line">mq=int(pow(c,(q+1)//4,q))</span><br><span class="line">a=(inv_p*p*mq+inv_q*q*mp)%n</span><br><span class="line">b=n-int(a)</span><br><span class="line">c=(inv_p*p*mq-inv_q*q*mp)%n</span><br><span class="line">d=n-int(c)</span><br><span class="line">result=[a,b,c,d]</span><br><span class="line">for m in result:</span><br><span class="line">    t=hex(m)</span><br><span class="line">    g=str(t)</span><br><span class="line">    l=len(g)//2-1</span><br><span class="line">    s=&#x27;&#x27;</span><br><span class="line">    for i in range(l):</span><br><span class="line">        s=s+chr(int(g[2+2*i]+g[3+2*i],16))</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure>
<p>运行后得到的四段中只有一段是有效的flag，提交这一段即可。</p>
<h2 id="30-BJDCTF-2nd-燕言燕语-y1ng"><a href="#30-BJDCTF-2nd-燕言燕语-y1ng" class="headerlink" title="30. [BJDCTF 2nd]燕言燕语-y1ng"></a>30. [BJDCTF 2nd]燕言燕语-y1ng</h2><p>首先把给的十六进制的数用ASCII码编码为对应的字符，得到：<br><code>yanzi ZJQ&#123;xilzv_iqssuhoc_suzjg&#125;</code><br>后面的部分显然是flag经过维吉尼亚密码变换后得到的结果，尝试猜测明文。首先这个比赛是BJDCTF，所以ZJQ大概率是由BJD变换过来的。再看到前面的“yanzi”刚好有五个字符，而大括号里面下划线隔开的部分中也有两个部分刚好是由五个字符组成的，可以合理猜测这两个里面有一个就是“yanzi”这五个字符。先尝试前面这五个字符，发现正好能解密出一句完整的话，成功获取到flag。<br>这道题的关键在于明文的猜测，也就是需要理解出题人给的“yanzi”这个提示的含义。因为在flag里面组成的话一般都是英语的，所以我一开始以为这是什么特殊的加密方法。百度之后没有什么收获，最后才知道这个提示原来就是明文的一部分。</p>
<h2 id="31-信息化时代的步伐"><a href="#31-信息化时代的步伐" class="headerlink" title="31. 信息化时代的步伐"></a>31. 信息化时代的步伐</h2><p>这是一种中文电码，可以使用下面的网站解码：中文电码查询 Chinese Commercial Code - 标准电报码免费在线查询|姓名电码|美国签证电码</p>
<h2 id="32-凯撒？替换？呵呵"><a href="#32-凯撒？替换？呵呵" class="headerlink" title="32. 凯撒？替换？呵呵!"></a>32. 凯撒？替换？呵呵!</h2><p>记录一个可以很方便列举凯撒密码的可能性的网站：quipqiup - cryptoquip and cryptogram solver</p>
<h2 id="33-萌萌哒的八戒"><a href="#33-萌萌哒的八戒" class="headerlink" title="33. 萌萌哒的八戒"></a>33. 萌萌哒的八戒</h2><p>看到八戒和密码就知道是猪圈密码，这里记录一个猪圈密码的图片。<br>（图片来自CTF密码学常见加密解密总结_wydfxjmgvswodododod-CSDN博客）</p>
<h2 id="34-传统知识-古典密码"><a href="#34-传统知识-古典密码" class="headerlink" title="34. 传统知识+古典密码"></a>34. 传统知识+古典密码</h2><p>这道题中使用到了我国传统的天干地支，这里附一张天干地支的计数表：<br>题目中提示说“+甲子”，甲子在表里面表示1，但是把解密出来的数字加一并没有什么效果，所以想到甲子还有另一层意思，就是一轮，也就是六十，再把解密出来的数字加六十，用ASCII码找到对应的英文字符，即可得到一串没有任何意义的字母。<br>看到题目里有“古典密码”的提示，使用在线工具 - Bugku CTF中的栅栏加密和凯撒加密的工具进行穷举，终于找到了一串有含义的中文拼音：<code>SHUANGYU</code>，包上flag提交即可。</p>
<h2 id="35-AFCTF2018-Morse"><a href="#35-AFCTF2018-Morse" class="headerlink" title="35. [AFCTF2018]Morse"></a>35. [AFCTF2018]Morse</h2><p>这也是一道摩斯编码的题目，由于摩斯码较长，找了一个解码的网站：摩尔斯电码转换器：在线进行摩尔斯电码和英文字母的相互转换，可以把莫尔斯电码转换为英文字母，也可把英文字母转换为摩尔斯电码</p>
<h2 id="36-NewStarCTF-2023-公开赛道-RSA-Variation-II"><a href="#36-NewStarCTF-2023-公开赛道-RSA-Variation-II" class="headerlink" title="36.[NewStarCTF 2023 公开赛道]RSA Variation II"></a>36.[NewStarCTF 2023 公开赛道]RSA Variation II</h2><p>根据提示知道是一种Schmidt-Samoa密码系统，可以通过推导得到计算flag的方法。<br>首先列出题目条件：</p>
<p>由（2）式可知存在k使得</p>
<p>不妨设gcd(p-1,q-1)为x，那么有</p>
<p>在传统的rsa加密中，由费马小定理我们可以得到：</p>
<p>那么我们任取一个a，利用（4）式可以知道</p>
<p>将上式最左边和最右边同时乘以-x次方，可以得到</p>
<p>于是知道，对于任意一个a来说，存在t使得</p>
<p>那么我们任取两个不同的a，计算出满足（5）式的两个不同的数值，然后求他们的最大公约数，就能得到p*q的值，再利用（1）式就能计算出p、q的值。用sagemath写出脚本：   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">N = 1768427447158131856514034889456397424027937796617829756303525705316152314769129050888899742667986532346611229157207778487065194513722005516611969754197481310330149721054855689646133721600838194741123290410384315980339516947257172981002480414254023253269098539962527834174781356657779988761754582343096332391763560921491414520707112852896782970123018263505426447126195645371941116395659369152654368118569516482251442513192892626222576419747048343942947570016045016127917578272819812760632788343321742583353340158009324794626006731057267603803701663256706597904789047060978427573361035171008822467120148227698893238773305320215769410594974360573727150122036666987718934166622785421464647946084162895084248352643721808444370307254417501852264572985908550839933862563001186477021313236113690793843893640190378131373214104044465633483953616402680853776480712599669132572907096151664916118185486737463253559093537311036517461749439</span><br><span class="line">d = 20650646933118544225095544552373007455928574480175801658168105227037950105642248948645762488881219576174131624593293487325329703919313156659700002234392400636474610143032745113473842675857323774566945229148664969659797779146488402588937762391470971617163496433008501858907585683428652637958844902909796849080799141999490231877378863244093900363251415972834146031490928923962271054053278056347181254936750536280638321211545167520935870220829786490686826062142415755063724639110568511969041175019898031990455911525941036727091961083201123910761290998968240338217895275414072475701909497518616112236380389851984377079</span><br><span class="line">pq = gcd(Integer(pow(2,d*N,N)-2),Integer(pow(3,d*N,N)-3))</span><br><span class="line">p=N//pq</span><br><span class="line">q=pq//p</span><br><span class="line">print(p)</span><br><span class="line">print(q)</span><br></pre></td></tr></table></figure>
<p>接下来需要变换（3）式尝试得到m的值。<br>结合（1）式和（3）式，我们知道</p>
<p>等式两边同时乘以d*x次方，则有</p>
<p>结合（4）式可以得到</p>
<p>两边再同时乘以-x次方，即可得到</p>
<p>利用这个式子就能计算出m的值，从而得到flag。</p>
<h2 id="37-NewStarCTF-2023-公开赛道-Small-d"><a href="#37-NewStarCTF-2023-公开赛道-Small-d" class="headerlink" title="37. [NewStarCTF 2023 公开赛道]Small d"></a>37. [NewStarCTF 2023 公开赛道]Small d</h2><p>根据提示需要使用维纳攻击的方法，到网上找了一个相关的脚本，用sagemath运行一下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">def rational_to_contfrac(x,y):</span><br><span class="line">    a = x // y</span><br><span class="line">    pquotients = [a]</span><br><span class="line">    while a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        pquotients.append(a)</span><br><span class="line">    return pquotients</span><br><span class="line">def convergents_from_contfrac(frac):</span><br><span class="line">    convs = [];</span><br><span class="line">    for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i]))</span><br><span class="line">    return convs</span><br><span class="line">def contfrac_to_rational (frac):</span><br><span class="line">    if len(frac) == 0: return (0,1)</span><br><span class="line">    num = frac[-1]</span><br><span class="line">    denom = 1</span><br><span class="line">    for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num</span><br><span class="line">    return (num, denom)</span><br><span class="line">c = 6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248</span><br><span class="line">e = 8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825</span><br><span class="line">n = 19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433</span><br><span class="line">def egcd(a, b):</span><br><span class="line">    if a == 0: return (b, 0, 1)</span><br><span class="line">    g, x, y = egcd(b % a, a)</span><br><span class="line">    return (g, y - (b // a) * x, x)</span><br><span class="line">def mod_inv(a, m):</span><br><span class="line">    g, x, _ = egcd(a, m)</span><br><span class="line">    return (x + m) % m</span><br><span class="line">def isqrt(n):</span><br><span class="line">    x = n</span><br><span class="line">    y = (x + 1) // 2</span><br><span class="line">    while y &lt; x:</span><br><span class="line">        x = y</span><br><span class="line">        y = (x + n // x) // 2</span><br><span class="line">    return x</span><br><span class="line">def crack_rsa(e, n):</span><br><span class="line">    frac = rational_to_contfrac(e, n)</span><br><span class="line">    convergents = convergents_from_contfrac(frac)</span><br><span class="line">    for (k, d) in convergents:</span><br><span class="line">        if k != 0 and (e * d - 1) % k == 0:</span><br><span class="line">            phi = (e * d - 1) // k</span><br><span class="line">            s = n - phi + 1</span><br><span class="line">            # check if x*x - s*x + n = 0 has integer roots</span><br><span class="line">            D = s * s - 4 * n</span><br><span class="line">            if D &gt;= 0:</span><br><span class="line">                sq = isqrt(D)</span><br><span class="line">                if sq * sq == D and (s + sq) % 2 == 0: return d</span><br><span class="line">d = crack_rsa(e, n)</span><br><span class="line">m = hex(pow(c, d, n))[2:]</span><br><span class="line">print(bytes.fromhex(m))</span><br></pre></td></tr></table></figure>
<p>（函数脚本来自Lazzaro @ 分类 | Lazzaro）</p>
<h2 id="38-NewStarCTF-公开赛赛道-ezRabin"><a href="#38-NewStarCTF-公开赛赛道-ezRabin" class="headerlink" title="38. [NewStarCTF 公开赛赛道]ezRabin"></a>38. [NewStarCTF 公开赛赛道]ezRabin</h2><p>这道题里面e使用了4，是2的两倍，所以只要使用两次rabin加密的解密算法就能得到结果，直接上sagemath的脚本：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">c=59087040011818617875466940950576089096932769518087477304162753047334728508009365510335057824251636964132317478310267427589970177277870220660958570994888152191522928881774614096675980017700457666192609573774572571582962861504174396725705862549311100229145101667835438230371282904888448863223898642183925834109</span><br><span class="line">p=10522889477508921233145726452630168129218487981917965097647277937267556441871668611904567713868254050044587941828674788953975031679913879970887998582514571</span><br><span class="line">q=11287822338267163056031463255265099337492571870189068887689824393221951058498526362126606231275830844407608185240702408947800715624427717739233431252556379</span><br><span class="line">n=p*q</span><br><span class="line">inv_p=int(pow(p,-1,q))</span><br><span class="line">inv_q=int(pow(q,-1,p))</span><br><span class="line">mp=int(pow(c,(p+1)//4,p))</span><br><span class="line">mq=int(pow(c,(q+1)//4,q))</span><br><span class="line">a=(inv_p*p*mq+inv_q*q*mp)%n</span><br><span class="line">b=n-int(a)</span><br><span class="line">c=(inv_p*p*mq-inv_q*q*mp)%n</span><br><span class="line">d=n-int(c)</span><br><span class="line">result=[a,b,c,d]</span><br><span class="line">re=[]</span><br><span class="line">for m in result:</span><br><span class="line">    mp=int(pow(m,(p+1)//4,p))</span><br><span class="line">    mq=int(pow(m,(q+1)//4,q))</span><br><span class="line">    a=(inv_p*p*mq+inv_q*q*mp)%n</span><br><span class="line">    b=n-int(a)</span><br><span class="line">    c=(inv_p*p*mq-inv_q*q*mp)%n</span><br><span class="line">    d=n-int(c)</span><br><span class="line">    re.append(a)</span><br><span class="line">    re.append(b)</span><br><span class="line">    re.append(c)</span><br><span class="line">    re.append(d)</span><br><span class="line">for m in re:</span><br><span class="line">    m=m&gt;&gt;300</span><br><span class="line">    t=hex(m)</span><br><span class="line">    g=str(t)</span><br><span class="line">    l=len(g)//2-1</span><br><span class="line">    s=&#x27;&#x27;</span><br><span class="line">    for i in range(l):</span><br><span class="line">        s=s+chr(int(g[2+2*i]+g[3+2*i],16))</span><br><span class="line">    print(s)</span><br></pre></td></tr></table></figure>
<h2 id="39-NewStarCTF-2023-公开赛道-partial-decrypt"><a href="#39-NewStarCTF-2023-公开赛道-partial-decrypt" class="headerlink" title="39. [NewStarCTF 2023 公开赛道]partial decrypt"></a>39. [NewStarCTF 2023 公开赛道]partial decrypt</h2><p>首先在rsa中，我们有</p>
<p>那么就有</p>
<p>考虑模p的情况，对于任意的a有</p>
<p>所以</p>
<p>即存在 使得</p>
<p>同理，存在 使得</p>
<p>题中已知</p>
<p>把（1）、（2）式代入（3）中，可以得到</p>
<p>此时发现，我们知道了 、 、q的值，可以由（2）式计算出m的值了。</p>
<h2 id="40-V-N2020-公开赛-CRT"><a href="#40-V-N2020-公开赛-CRT" class="headerlink" title="40. [V&amp;N2020 公开赛]CRT"></a>40. [V&amp;N2020 公开赛]CRT</h2><p>这是一道扩展的中国剩余定理的题目，直接上大佬的脚本得到所需求的数的模数和取模之后的值，然后遍历所有可能的结果，寻找符合条件的结果，即为最终的flag。下面是修改后sagemath的脚本：   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">def CRT(mi, ai):</span><br><span class="line">	curm, cura = mi[0], ai[0]</span><br><span class="line">	for (m, a) in zip(mi[1:], ai[1:]):</span><br><span class="line">		d =gcd(curm, m)</span><br><span class="line">		c = a - cura</span><br><span class="line">		assert (c % d == 0) </span><br><span class="line">		K = c // d * gmpy2.invert(curm // d, m // d)</span><br><span class="line">		cura += curm * K</span><br><span class="line">		curm = curm * m // d</span><br><span class="line">	return (cura % curm, curm) </span><br><span class="line">ms = [284461942441737992421992210219060544764, 218436209063777179204189567410606431578, 288673438109933649911276214358963643204, 239232622368515797881077917549177081575, 206264514127207567149705234795160750411, 338915547568169045185589241329271490503, 246545359356590592172327146579550739141, 219686182542160835171493232381209438048]</span><br><span class="line">cs = [273520784183505348818648859874365852523, 128223029008039086716133583343107528289, 5111091025406771271167772696866083419, 33462335595116820423587878784664448439, 145377705960376589843356778052388633917, 128158421725856807614557926615949143594, 230664008267846531848877293149791626711, 94549019966480959688919233343793910003]</span><br><span class="line">(x,y)=CRT(ms,cs)</span><br><span class="line">x=int(x)</span><br><span class="line">y=int(y)</span><br><span class="line">x=331928385895936850327248455618550267979226366540503309505403897762924348214252184339508819167395418477591466337317495869131189862837240599867138359384794556128835111222068761517340369160010091387517644467690158341517036316714577728109817419385351326590048046021467528943086247709683222909672931154665939</span><br><span class="line">y=466244535277126133494171720905467305227449898136540531771165702728811600035193763296997575538712880600873766336223021102495903920660547449598419752724436481022338453912400904360309909376397024992632893902959636099041017419464716113173886710394215080355542879719231888389121865360597540403463754208728800</span><br><span class="line">k=1</span><br><span class="line">while True:</span><br><span class="line">    flag = &quot;flag&#123;&quot; + hashlib.sha256(str(x+k*y).encode()).hexdigest() + &quot;&#125;&quot;</span><br><span class="line">    if &quot;4b93deeb&quot; in flag:</span><br><span class="line">        print(flag)</span><br><span class="line">        break</span><br><span class="line">    k+=1</span><br></pre></td></tr></table></figure>
<p>（函数脚本来自Lazzaro @ 分类 | Lazzaro）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" data-id="cm1ec5c940000q0tw31508ggt" data-title="BUUCTF刷题记录" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf-crypto/" rel="tag">ctf crypto</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-web" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/web/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:19:15.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/web/">web</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="MD5弱碰撞"><a href="#MD5弱碰撞" class="headerlink" title="MD5弱碰撞"></a>MD5弱碰撞</h2><p>PHP在处理哈希字符串时，会利用”!&#x3D;”或”&#x3D;&#x3D;”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。攻击者可以利用这一漏洞，通过输入一个经过哈希后以”0E”开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以”0E”开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。<br>以下是一些0e开头的字符串：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QNKCDZO</span><br><span class="line">0e830400451993494058024219903391</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/web/" data-id="cm1ec5c9j0006q0tw3kurgynr" data-title="web" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf-web/" rel="tag">ctf web</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-crypto" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/crypto/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:18:43.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/crypto/">crypto</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h2><p><a target="_blank" rel="noopener" href="http://factordb.com/">因数分解网站</a>  </p>
<h3 id="e的值很小"><a href="#e的值很小" class="headerlink" title="e的值很小"></a>e的值很小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">//导入n，e，c的值</span><br><span class="line">for i in range(10000):   //遍历循环，找到m值</span><br><span class="line">    m, t = gmpy2.iroot(i*n + c, e)</span><br><span class="line">    if t:</span><br><span class="line">        print(bytearray.fromhex(format(m, &#x27;x&#x27;)).decode()) //将十六进制字符串转换为字节后解密</span><br><span class="line">       	break</span><br></pre></td></tr></table></figure>

<h3 id="两次加密存在一个相同的质数"><a href="#两次加密存在一个相同的质数" class="headerlink" title="两次加密存在一个相同的质数"></a>两次加密存在一个相同的质数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import powmod as po, gmpy2</span><br><span class="line">import sympy</span><br><span class="line">c1 = </span><br><span class="line">c2 = </span><br><span class="line">n1 = </span><br><span class="line">n2 = </span><br><span class="line">e = </span><br><span class="line">q = gmpy2.gcd(n1, n2)  # 求n1和n2的最大公因数</span><br><span class="line">p1 = n1 // q</span><br><span class="line">p2 = n2 // q</span><br><span class="line">fn1 = (q - 1) * (p1 - 1)  # 求下面的&amp;n</span><br><span class="line">fn2 = (q - 1) * (p2 - 1)  # 求上面的&amp;n</span><br><span class="line">d1 = inverse(e, fn1)  # (de)mod((p-1)*(q-1))=1  求到第一个解密密钥d1</span><br><span class="line">d2 = inverse(e, fn2)  # 求出第二个解密密钥d2</span><br><span class="line">m1 = pow(c1, d1, n1)</span><br><span class="line">m2 = pow(c2, d2, n2)</span><br><span class="line">print(long_to_bytes(m1))</span><br><span class="line">print(long_to_bytes(m2))</span><br></pre></td></tr></table></figure>
<h3 id="同一个n用两个e进行加密"><a href="#同一个n用两个e进行加密" class="headerlink" title="同一个n用两个e进行加密"></a>同一个n用两个e进行加密</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import gmpy2</span><br><span class="line">flag1 = </span><br><span class="line">flag2 = </span><br><span class="line">e1 = </span><br><span class="line">e2 = </span><br><span class="line">n = </span><br><span class="line">def rsa_gong_N_def(e1, e2, c1, c2, n):</span><br><span class="line">   	e1, e2, c1, c2, n = int(e1), int(e2), int(c1), int(c2), int(n)</span><br><span class="line">   	s = gmpy2.gcdext(e1, e2)  # 扩展欧几里得算法  t*e1+z*e2=1,求出t和z</span><br><span class="line">   	t = s[1]</span><br><span class="line">   	z = s[2]</span><br><span class="line">   	if t &lt; 0:  # 要求c的s次幂，就要先计算c的模反元素c2r，然后求c2r的-s2次幂</span><br><span class="line">   	    t = - t</span><br><span class="line">   	    c1 = gmpy2.invert(c1, n)  # 求c1的逆元</span><br><span class="line">   	elif z &lt; 0:</span><br><span class="line">   	    z = -z</span><br><span class="line">   	    c2 = gmpy2.invert(c2, n)</span><br><span class="line">   	m = (pow(c1, t, n) * pow(c2, z, n)) % n  # (c1^s1*c2^s2)%n=m%n=m</span><br><span class="line">   	return m</span><br><span class="line">result = rsa_gong_N_def(e1, e2, flag1, flag2, n)</span><br><span class="line">print(long_to_bytes(result))</span><br></pre></td></tr></table></figure>
<h3 id="有四个质数，其中两个是另外两个的next-prime，已知他们四个数的乘积"><a href="#有四个质数，其中两个是另外两个的next-prime，已知他们四个数的乘积" class="headerlink" title="有四个质数，其中两个是另外两个的next_prime，已知他们四个数的乘积"></a>有四个质数，其中两个是另外两个的next_prime，已知他们四个数的乘积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import sympy</span><br><span class="line">e = </span><br><span class="line">n1 = </span><br><span class="line">c1 = </span><br><span class="line">def fermat_factorization(n):</span><br><span class="line">   	factor_list = []</span><br><span class="line">   	get_context().precision = 2048	</span><br><span class="line">   	sqrt_n = int(sqrt(n))</span><br><span class="line">   	c = sqrt_n</span><br><span class="line">   	while True:</span><br><span class="line">   	    c += 1</span><br><span class="line">   	    d_square = c**2 - n</span><br><span class="line">   	    if is_square(d_square):</span><br><span class="line">   	        d_square = mpz(d_square)</span><br><span class="line">   	        get_context().precision = 2048</span><br><span class="line">   	        d = int(sqrt(d_square))</span><br><span class="line">   	        factor_list.append([c+d,c-d])</span><br><span class="line">   	    if len(factor_list)==2:</span><br><span class="line">   	        break</span><br><span class="line">   	return factor_list</span><br><span class="line">factor_list = fermat_factorization(n1)</span><br><span class="line">[X1,Y1] = factor_list[0]	#费马函数分解</span><br><span class="line">[X2,Y2] = factor_list[1]</span><br><span class="line">assert X1*Y1 == n1</span><br><span class="line">assert X2*Y2 == n1</span><br><span class="line">p1 = gcd(X1,X2)</span><br><span class="line">q1 = X1 // p1		</span><br><span class="line">p2 = gcd(Y1,Y2)</span><br><span class="line">q2 = Y1 // p2</span><br><span class="line">phi1 = (p1-1)*(q1-1)*(p2-1)*(q2-1)	#求φ(n)</span><br><span class="line">d1 = invert(e,phi1)		#常规RSA解密流程求d</span><br><span class="line">print(long_to_bytes(gmpy2.powmod(c1,d1,n1)),end=&#x27;&#x27;)	##常规RSA解密流程求明文</span><br></pre></td></tr></table></figure>
<h3 id="dp泄露"><a href="#dp泄露" class="headerlink" title="dp泄露"></a>dp泄露</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">def rsa(e,n,dp,c):</span><br><span class="line">   	p=0</span><br><span class="line">   	for i in range(1,e):</span><br><span class="line">   	    if (e*dp-1)%i==0:</span><br><span class="line">   	        p=(e*dp-1)//i+1</span><br><span class="line">   	        if n%p==0:</span><br><span class="line">   	            break</span><br><span class="line">   	q=n//p</span><br><span class="line">   	d=invert(e,(p-1)*(q-1))</span><br><span class="line">   	print(long_to_bytes(pow(c,d,n)))</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   	e =</span><br><span class="line">   	n = </span><br><span class="line">   	dp = </span><br><span class="line">   	c = </span><br><span class="line">   	rsa(e,n,dp,c)</span><br></pre></td></tr></table></figure>
<h3 id="维纳攻击方法（当e的值非常大的时候使用）"><a href="#维纳攻击方法（当e的值非常大的时候使用）" class="headerlink" title="维纳攻击方法（当e的值非常大的时候使用）"></a>维纳攻击方法（当e的值非常大的时候使用）</h3><p>文件1：Arithmetic.py（后面引用，勿改名）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">def egcd(a,b):</span><br><span class="line">   	u, u1 = 1, 0</span><br><span class="line">   	v, v1 = 0, 1</span><br><span class="line">   	while b:</span><br><span class="line">   	    q = a // b</span><br><span class="line">   	    u, u1 = u1, u - q * u1</span><br><span class="line">   	    v, v1 = v1, v - q * v1</span><br><span class="line">   	    a, b = b, a - q * b</span><br><span class="line">   	return u, v, a</span><br><span class="line">def gcd(a,b):</span><br><span class="line">   	a,b=(b,a) if a&lt;b else (a,b)</span><br><span class="line">   	while b:</span><br><span class="line">   	    a,b=b,a%b</span><br><span class="line">   	return a</span><br><span class="line">def modInverse(e,n):</span><br><span class="line">	return egcd(e,n)[0]%n</span><br><span class="line">def totient(p,q):</span><br><span class="line">   	return (p-1)*(q-1)</span><br><span class="line">def bitlength(x):</span><br><span class="line">   	assert x &gt;= 0</span><br><span class="line">   	n = 0</span><br><span class="line">   	while x &gt; 0:</span><br><span class="line">   	    n = n+1</span><br><span class="line">   	    x = x&gt;&gt;1</span><br><span class="line">   	return n</span><br><span class="line">def isqrt(n):</span><br><span class="line">   	if n &lt; 0:</span><br><span class="line">   	    raise ValueError(&#x27;square root not defined for negative numbers&#x27;)</span><br><span class="line">   	if n == 0:</span><br><span class="line">   	    return 0</span><br><span class="line">   	a, b = divmod(bitlength(n), 2)</span><br><span class="line">   	x = 2**(a+b)</span><br><span class="line">   	while True:</span><br><span class="line">   	    y = (x + n//x)//2</span><br><span class="line">   	    if y &gt;= x:</span><br><span class="line">   	        return x</span><br><span class="line">   	    x = y</span><br><span class="line">def is_perfect_square(n):</span><br><span class="line">   	h = n &amp; 0xF; </span><br><span class="line">   	if h &gt; 9:</span><br><span class="line">   	    return -1 </span><br><span class="line">   	if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):</span><br><span class="line">   	    t = isqrt(n)</span><br><span class="line">   	    if t*t == n:</span><br><span class="line">   	        return t</span><br><span class="line">   	    else:</span><br><span class="line">   	        return -1</span><br><span class="line">   	return -1</span><br></pre></td></tr></table></figure>
<p>文件2：ContinuedFractions.py（后面引用，勿改名）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from typing import List,Tuple</span><br><span class="line">CFListT = List[int]  </span><br><span class="line">CVListT = List[Tuple[int, int]] </span><br><span class="line">def rational_to_contfrac(x: int, y: int) -&gt; Tuple[CFListT, CVListT]:</span><br><span class="line">    a = x // y</span><br><span class="line">    cflist = [a]</span><br><span class="line">    cvlist = [(a, 1)]</span><br><span class="line">    ppn, ppd = 1, 0 </span><br><span class="line">    pn, pd = a, 1  </span><br><span class="line">    while a * y != x:</span><br><span class="line">        x, y = y, x - a * y</span><br><span class="line">        a = x // y</span><br><span class="line">        cflist.append(a)</span><br><span class="line">        cn, cd = a * pn + ppn, a * pd + ppd</span><br><span class="line">        cvlist.append((cn, cd))</span><br><span class="line">        ppn, ppd = pn, pd</span><br><span class="line">        pn, pd = cn, cd</span><br><span class="line">return cflist, cvlist</span><br></pre></td></tr></table></figure>
<p>文件3：运行的文件，可随意取名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">import sympy</span><br><span class="line">import ContinuedFractions, Arithmetic</span><br><span class="line">def hack_RSA(e,n):</span><br><span class="line">    _, convergents = ContinuedFractions.rational_to_contfrac(e, n)   </span><br><span class="line">    for (k,d) in convergents:</span><br><span class="line">        if k!=0 and (e*d-1)%k == 0:</span><br><span class="line">            phi = (e*d-1)//k</span><br><span class="line">            s = n - phi + 1</span><br><span class="line">            discr = s*s - 4*n</span><br><span class="line">            if(discr&gt;=0):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                if t!=-1 and (s+t)%2==0:</span><br><span class="line">                    print(&quot;Hacked!&quot;)</span><br><span class="line">                    return d</span><br><span class="line">e=</span><br><span class="line">n=</span><br><span class="line">ct=</span><br><span class="line">d=hack_RSA(e,n)</span><br><span class="line">print(d)</span><br><span class="line">h=pow(  ct, d, n)</span><br><span class="line">print(h)</span><br><span class="line">print(long_to_bytes(h))</span><br></pre></td></tr></table></figure>
<h3 id="RSA中的Boneh-Durfee-Attack攻击方法"><a href="#RSA中的Boneh-Durfee-Attack攻击方法" class="headerlink" title="RSA中的Boneh Durfee Attack攻击方法"></a>RSA中的Boneh Durfee Attack攻击方法</h3><p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/shshss64/article/details/129605810?app_version=6.3.7&code=app_1562916241&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22129605810%22,%22source%22:%222301_79140522%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app">链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">debug = True</span><br><span class="line">strict = False</span><br><span class="line">helpful_only = True</span><br><span class="line">dimension_min = 7 # stop removing if lattice reaches that dimension</span><br><span class="line">def helpful_vectors(BB, modulus):</span><br><span class="line">   	nothelpful = 0</span><br><span class="line">   	for ii in range(BB.dimensions()[0]):</span><br><span class="line">   	    if BB[ii,ii] &gt;= modulus:</span><br><span class="line">   	        nothelpful += 1</span><br><span class="line">   	print(nothelpful, &quot;/&quot;, BB.dimensions()[0], &quot; vectors are not helpful&quot;)</span><br><span class="line"># display matrix picture with 0 and X</span><br><span class="line">def matrix_overview(BB, bound):</span><br><span class="line">    for ii in range(BB.dimensions()[0]):</span><br><span class="line">        a = (&#x27;%02d &#x27; % ii)</span><br><span class="line">        for jj in range(BB.dimensions()[1]):</span><br><span class="line">            a += &#x27;0&#x27; if BB[ii,jj] == 0 else &#x27;X&#x27;</span><br><span class="line">            if BB.dimensions()[0] &lt; 60:</span><br><span class="line">                a += &#x27; &#x27;</span><br><span class="line">        if BB[ii, ii] &gt;= bound:</span><br><span class="line">            a += &#x27;~&#x27;</span><br><span class="line">        print(a)</span><br><span class="line">def remove_unhelpful(BB, monomials, bound, current):</span><br><span class="line">   	# end of our recursive function</span><br><span class="line">   	if current == -1 or BB.dimensions()[0] &lt;= dimension_min:</span><br><span class="line">   	    return BB</span><br><span class="line">   	# we start by checking from the end</span><br><span class="line">   	for ii in range(current, -1, -1):</span><br><span class="line">   	    # if it is unhelpful:</span><br><span class="line">   	    if BB[ii, ii] &gt;= bound:</span><br><span class="line">   	        affected_vectors = 0</span><br><span class="line">   	        affected_vector_index = 0</span><br><span class="line">   	        # let&#x27;s check if it affects other vectors</span><br><span class="line">   	        for jj in range(ii + 1, BB.dimensions()[0]):</span><br><span class="line">   	            if BB[jj, ii] != 0:</span><br><span class="line">   	                affected_vectors += 1</span><br><span class="line">   	                affected_vector_index = jj</span><br><span class="line">   	        if affected_vectors == 0:</span><br><span class="line">   	            print(&quot;* removing unhelpful vector&quot;, ii)</span><br><span class="line">   	            BB = BB.delete_columns([ii])</span><br><span class="line">   	            BB = BB.delete_rows([ii])</span><br><span class="line">   	            monomials.pop(ii)</span><br><span class="line">   	            BB = remove_unhelpful(BB, monomials, bound, ii-1)</span><br><span class="line">   	            return BB</span><br><span class="line">   	        elif affected_vectors == 1:</span><br><span class="line">   	            affected_deeper = True</span><br><span class="line">   	            for kk in range(affected_vector_index + 1, BB.dimensions()[0]):</span><br><span class="line">   	                if BB[kk, affected_vector_index] != 0:</span><br><span class="line">   	                    affected_deeper = False</span><br><span class="line">   	            if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]):</span><br><span class="line">   	                print(&quot;* removing unhelpful vectors&quot;, ii, &quot;and&quot;, affected_vector_index)</span><br><span class="line">   	                BB = BB.delete_columns([affected_vector_index, ii])</span><br><span class="line">   	                BB = BB.delete_rows([affected_vector_index, ii])</span><br><span class="line">   	                monomials.pop(affected_vector_index)</span><br><span class="line">   	                monomials.pop(ii)</span><br><span class="line">   	                BB = remove_unhelpful(BB, monomials, bound, ii-1)</span><br><span class="line">   	                return BB</span><br><span class="line">   	# nothing happened</span><br><span class="line">   	return BB</span><br><span class="line">def boneh_durfee(pol, modulus, mm, tt, XX, YY):</span><br><span class="line">   	# substitution (Herrman and May)</span><br><span class="line">   	PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)</span><br><span class="line">   	Q = PR.quotient(x*y + 1 - u) # u = xy + 1</span><br><span class="line">   	polZ = Q(pol).lift()</span><br><span class="line"></span><br><span class="line">   	UU = XX*YY + 1</span><br><span class="line"></span><br><span class="line">   	gg = []</span><br><span class="line">   	for kk in range(mm + 1):</span><br><span class="line">   	    for ii in range(mm - kk + 1):</span><br><span class="line">   	        xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk</span><br><span class="line">   	        gg.append(xshift)</span><br><span class="line">   	gg.sort()</span><br><span class="line"></span><br><span class="line">   	# x-shifts list of monomials</span><br><span class="line">   	monomials = []</span><br><span class="line">   	for polynomial in gg:</span><br><span class="line">   	    for monomial in polynomial.monomials():</span><br><span class="line">   	        if monomial not in monomials:</span><br><span class="line">   	            monomials.append(monomial)</span><br><span class="line">   	monomials.sort()</span><br><span class="line">   </span><br><span class="line">   	# y-shifts (selected by Herrman and May)</span><br><span class="line">   	for jj in range(1, tt + 1):</span><br><span class="line">   	    for kk in range(floor(mm/tt) * jj, mm + 1):</span><br><span class="line">   	        yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)</span><br><span class="line">   	        yshift = Q(yshift).lift()</span><br><span class="line">   	        gg.append(yshift) # substitution</span><br><span class="line">   </span><br><span class="line">   	# y-shifts list of monomials</span><br><span class="line">   	for jj in range(1, tt + 1):</span><br><span class="line">   	    for kk in range(floor(mm/tt) * jj, mm + 1):</span><br><span class="line">   	        monomials.append(u^kk * y^jj)</span><br><span class="line">	</span><br><span class="line">   	# construct lattice B</span><br><span class="line">   	nn = len(monomials)</span><br><span class="line">   	BB = Matrix(ZZ, nn)</span><br><span class="line">   	for ii in range(nn):</span><br><span class="line">   	    BB[ii, 0] = gg[ii](0, 0, 0)</span><br><span class="line">   	    for jj in range(1, ii + 1):</span><br><span class="line">   	        if monomials[jj] in gg[ii].monomials():</span><br><span class="line">   	            BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)</span><br><span class="line">   	if helpful_only:</span><br><span class="line">   	    BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1)</span><br><span class="line">   	    nn = BB.dimensions()[0]</span><br><span class="line">   	    if nn == 0:</span><br><span class="line">   	        print(&quot;failure&quot;)</span><br><span class="line">   	        return 0,0</span><br><span class="line">   	if debug:</span><br><span class="line">   	    helpful_vectors(BB, modulus^mm)</span><br><span class="line">   	det = BB.det()</span><br><span class="line">   	bound = modulus^(mm*nn)</span><br><span class="line">   	if det &gt;= bound:</span><br><span class="line">   	    print(&quot;We do not have det &lt; bound. Solutions might not be found.&quot;)</span><br><span class="line">   	    print(&quot;Try with highers m and t.&quot;)</span><br><span class="line">   	    if debug:</span><br><span class="line">   	        diff = (log(det) - log(bound)) / log(2)</span><br><span class="line">   	        print(&quot;size det(L) - size e^(m*n) = &quot;, floor(diff))</span><br><span class="line">   	    if strict:</span><br><span class="line">   	        return -1, -1</span><br><span class="line">   	else:</span><br><span class="line">   	    print(&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;)</span><br><span class="line">   	if debug:</span><br><span class="line">       	matrix_overview(BB, modulus^mm)</span><br><span class="line">   	if debug:</span><br><span class="line">       	print(&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;)</span><br><span class="line"></span><br><span class="line">   	BB = BB.LLL()</span><br><span class="line"></span><br><span class="line">    if debug:</span><br><span class="line">   	    print(&quot;LLL is done!&quot;)</span><br><span class="line">   	if debug:</span><br><span class="line">   	    print(&quot;looking for independent vectors in the lattice&quot;)</span><br><span class="line">   	found_polynomials = False</span><br><span class="line">   	</span><br><span class="line">   	for pol1_idx in range(nn - 1):</span><br><span class="line">   	    for pol2_idx in range(pol1_idx + 1, nn):</span><br><span class="line">   	        # for i and j, create the two polynomials</span><br><span class="line">   	        PR.&lt;w,z&gt; = PolynomialRing(ZZ)</span><br><span class="line">   	        pol1 = pol2 = 0</span><br><span class="line">   	        for jj in range(nn):</span><br><span class="line">   	            pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line">   	            pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)</span><br><span class="line">   	        PR.&lt;q&gt; = PolynomialRing(ZZ)</span><br><span class="line">   	        rr = pol1.resultant(pol2)</span><br><span class="line">   	        if rr.is_zero() or rr.monomials() == [1]:</span><br><span class="line">   	            continue</span><br><span class="line">   	        else:</span><br><span class="line">   	            print(&quot;found them, using vectors&quot;, pol1_idx, &quot;and&quot;, pol2_idx)</span><br><span class="line">   	            found_polynomials = True</span><br><span class="line">   	            break</span><br><span class="line">   	    if found_polynomials:</span><br><span class="line">   	        break </span><br><span class="line">   	if not found_polynomials:</span><br><span class="line">   	    print(&quot;no independant vectors could be found. This should very rarely happen...&quot;)</span><br><span class="line">   	    return 0, 0 </span><br><span class="line">    rr = rr(q, q)</span><br><span class="line">   	soly = rr.roots() </span><br><span class="line">   	if len(soly) == 0:</span><br><span class="line">   	    print(&quot;Your prediction (delta) is too small&quot;)</span><br><span class="line">   	    return 0, 0</span><br><span class="line"></span><br><span class="line">   	soly = soly[0][0]</span><br><span class="line">   	ss = pol1(q, soly)</span><br><span class="line">   	solx = ss.roots()[0][0]</span><br><span class="line">   	return solx, soly</span><br><span class="line"></span><br><span class="line">def example(): </span><br><span class="line">   	N =     # the public exponent</span><br><span class="line">   	e = </span><br><span class="line">   	c = </span><br><span class="line">   	delta = .28 # this means that d &lt; N^delta</span><br><span class="line">   	m = 4 # size of the lattice (bigger the better/slower)</span><br><span class="line">   	t = int((1-2*delta) * m)  # optimization from Herrmann and May</span><br><span class="line">   	X = 2*floor(N^delta)  # this _might_ be too much</span><br><span class="line">   	Y = floor(N^(1/2))    # correct if p, q are ~ same size</span><br><span class="line">   	P.&lt;x,y&gt; = PolynomialRing(ZZ)</span><br><span class="line">   	A = int((N+1)/2)</span><br><span class="line">   	pol = 1 + x * (A + y)</span><br><span class="line">   	if debug:</span><br><span class="line">   	    print(&quot;=== checking values ===&quot;)</span><br><span class="line">   	    print(&quot;* delta:&quot;, delta)</span><br><span class="line">   	    print(&quot;* delta &lt; 0.292&quot;, delta &lt; 0.292)</span><br><span class="line">   	    print(&quot;* size of e:&quot;, int(log(e)/log(2)))</span><br><span class="line">   	    print(&quot;* size of N:&quot;, int(log(N)/log(2)))</span><br><span class="line">   	    print(&quot;* m:&quot;, m, &quot;, t:&quot;, t)</span><br><span class="line"></span><br><span class="line">   	if debug:</span><br><span class="line">   	    print(&quot;=== running algorithm ===&quot;)</span><br><span class="line">   	    start_time = time.time()</span><br><span class="line"></span><br><span class="line">   	solx, soly = boneh_durfee(pol, e, m, t, X, Y)</span><br><span class="line">	</span><br><span class="line">   	if solx &gt; 0:</span><br><span class="line">   	    print(&quot;=== solution found ===&quot;)</span><br><span class="line">   	    if False:</span><br><span class="line">   	        print(&quot;x:&quot;, solx)</span><br><span class="line">   	        print(&quot;y:&quot;, soly)</span><br><span class="line">	</span><br><span class="line">   	    d = int(pol(solx, soly) / e)</span><br><span class="line">   	    print(&quot;private key found:&quot;, d)</span><br><span class="line">   	    print(&quot;plaintext:&quot;, pow(c, d, N))</span><br><span class="line">   	else:</span><br><span class="line">   	    print(&quot;=== no solution was found ===&quot;)</span><br><span class="line"></span><br><span class="line">   	if debug:</span><br><span class="line">   	    print(&quot;=== %s seconds ===&quot; % (time.time() - start_time))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   	example()</span><br></pre></td></tr></table></figure>
<h2 id="prng算法（利用random-getrandbits函数只能产生固定数量的随机数）（梅森旋转算法）"><a href="#prng算法（利用random-getrandbits函数只能产生固定数量的随机数）（梅森旋转算法）" class="headerlink" title="prng算法（利用random.getrandbits函数只能产生固定数量的随机数）（梅森旋转算法）"></a>prng算法（利用random.getrandbits函数只能产生固定数量的随机数）（梅森旋转算法）</h2><h3 id="向后恢复随机数"><a href="#向后恢复随机数" class="headerlink" title="向后恢复随机数"></a>向后恢复随机数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from hashlib import sha256</span><br><span class="line">from randcrack import RandCrack //该库专门用来梅森旋转算法的破解</span><br><span class="line">t=[]</span><br><span class="line">rc = RandCrack()</span><br><span class="line">for i in t:</span><br><span class="line">   	rc.submit(i)</span><br><span class="line">flag1 = rc.predict_getrandbits(32)</span><br><span class="line">flag2 = rc.predict_getrandbits(32)</span><br><span class="line">print(sha256((str(flag1)+str(flag2)).encode()).hexdigest())</span><br></pre></td></tr></table></figure>
<p>利用别人写的脚本    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from random import Random</span><br><span class="line">def inverse_right(res,shift,bits=32):</span><br><span class="line">	tmp=res</span><br><span class="line">	for i in range(bits//shift):</span><br><span class="line">		tmp=res^tmp&gt;&gt;shift</span><br><span class="line">	return tmp</span><br><span class="line">def inverse_left_mask(res,shift,mask,bits=32):</span><br><span class="line">	tmp=res</span><br><span class="line">	for i in range(bits//shift):</span><br><span class="line">		tmp=res^tmp&lt;&lt;shift&amp;mask</span><br><span class="line">	return tmp</span><br><span class="line">def inv_extract_number(y):</span><br><span class="line">	y=inverse_right(y,18)</span><br><span class="line">	y=inverse_left_mask(y,15,4022730752)</span><br><span class="line">	y=inverse_left_mask(y,7,2636928640)</span><br><span class="line">	y=inverse_right(y,11)</span><br><span class="line">	return y&amp;0xffffffff</span><br><span class="line">def recover_mt(record):</span><br><span class="line">	state=[inv_extract_number(i) for i in record][:624]</span><br><span class="line">	gen=Random()</span><br><span class="line">	gen.setstate((3,tuple(state+[0]),None))</span><br><span class="line">	return gen</span><br><span class="line">ss=[]</span><br><span class="line">mt=recover_mt(ss)</span><br><span class="line">for i in range(624):</span><br><span class="line">	mt.getrandbits(32)</span><br><span class="line">print(mt.getrandbits(32))</span><br></pre></td></tr></table></figure>
<h3 id="向前恢复随机数"><a href="#向前恢复随机数" class="headerlink" title="向前恢复随机数"></a>向前恢复随机数</h3><p>首先下载库  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install extend_mt19937_predictor</span><br></pre></td></tr></table></figure>
<p>然后使用代码  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from extend_mt19937_predictor import ExtendMT19937Predictor</span><br><span class="line">numbers = []</span><br><span class="line">predictor = ExtendMT19937Predictor()</span><br><span class="line"></span><br><span class="line">for i in range(628):</span><br><span class="line">	predictor.setrandbits(numbers[i], 32)</span><br><span class="line">result = [predictor.backtrack_getrandbits(32) for _ in range(625)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>梅森旋转算法（亲测有效）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from hashlib import md5</span><br><span class="line">import random</span><br><span class="line">def _int32(x):</span><br><span class="line">   	return int(0xFFFFFFFF &amp; x)</span><br><span class="line">class MT19937:</span><br><span class="line">   	def __init__(self, seed=0):</span><br><span class="line">       	self.mt = [0] * 624</span><br><span class="line">       	self.mt[0] = seed</span><br><span class="line">       	self.mti = 0</span><br><span class="line">       	for i in range(1, 624):</span><br><span class="line">           	self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] &gt;&gt; 30) + i)</span><br><span class="line">   	def getstate(self,op=False):</span><br><span class="line">   	    if self.mti == 0 and op==False:</span><br><span class="line">   	        self.twist()</span><br><span class="line">   	    y = self.mt[self.mti]</span><br><span class="line">   	    y = y ^ y &gt;&gt; 11</span><br><span class="line">   	    y = y ^ y &lt;&lt; 7 &amp; 2636928640</span><br><span class="line">   	    y = y ^ y &lt;&lt; 15 &amp; 4022730752</span><br><span class="line">   	    y = y ^ y &gt;&gt; 18</span><br><span class="line">   	    self.mti = (self.mti + 1) % 624</span><br><span class="line">   	    return _int32(y)</span><br><span class="line">   	def twist(self):</span><br><span class="line">   	    for i in range(0, 624):</span><br><span class="line">   	        y = _int32((self.mt[i] &amp; 0x80000000) + (self.mt[(i + 1) % 624] &amp; 0x7fffffff))</span><br><span class="line">           self.mt[i] = (y &gt;&gt; 1) ^ self.mt[(i + 397) % 624]</span><br><span class="line">   	        if y % 2 != 0:</span><br><span class="line">   	            self.mt[i] = self.mt[i] ^ 0x9908b0df</span><br><span class="line">    def inverse_right(self,res, shift, mask=0xffffffff, bits=32):</span><br><span class="line">   	    tmp = res</span><br><span class="line">   	    for i in range(bits // shift):</span><br><span class="line">   	        tmp = res ^ tmp &gt;&gt; shift &amp; mask</span><br><span class="line">        return tmp</span><br><span class="line">   	def inverse_left(self,res, shift, mask=0xffffffff, bits=32):</span><br><span class="line">        tmp = res</span><br><span class="line">        for i in range(bits // shift):</span><br><span class="line">            tmp = res ^ tmp &lt;&lt; shift &amp; mask</span><br><span class="line">        return tmp</span><br><span class="line">    def extract_number(self,y):</span><br><span class="line">        y = y ^ y &gt;&gt; 11</span><br><span class="line">        y = y ^ y &lt;&lt; 7 &amp; 2636928640</span><br><span class="line">        y = y ^ y &lt;&lt; 15 &amp; 4022730752</span><br><span class="line">        y = y ^ y &gt;&gt; 18</span><br><span class="line">        return y&amp;0xffffffff</span><br><span class="line">    def recover(self,y):</span><br><span class="line">        y = self.inverse_right(y,18)</span><br><span class="line">        y = self.inverse_left(y,15,4022730752)</span><br><span class="line">        y = self.inverse_left(y,7,2636928640)</span><br><span class="line">        y = self.inverse_right(y,11)</span><br><span class="line">        return y&amp;0xffffffff</span><br><span class="line">    def setstate(self,s):</span><br><span class="line">        if(len(s)!=624):</span><br><span class="line">            raise ValueError(&quot;The length of prediction must be 624!&quot;)</span><br><span class="line">        for i in range(624):</span><br><span class="line">            self.mt[i]=self.recover(s[i])</span><br><span class="line">        #self.mt=s</span><br><span class="line">        self.mti=0</span><br><span class="line">    def predict(self,s):</span><br><span class="line">        self.setstate(s)</span><br><span class="line">        self.twist()</span><br><span class="line">        return self.getstate(True)</span><br><span class="line">    def invtwist(self):</span><br><span class="line">        high = 0x80000000</span><br><span class="line">        low = 0x7fffffff</span><br><span class="line">        mask = 0x9908b0df</span><br><span class="line">        for i in range(623,-1,-1):</span><br><span class="line">            tmp = self.mt[i]^self.mt[(i+397)%624]</span><br><span class="line">            if tmp &amp; high == high:</span><br><span class="line">                tmp ^= mask</span><br><span class="line">                tmp &lt;&lt;= 1</span><br><span class="line">                tmp |= 1</span><br><span class="line">            else:</span><br><span class="line">                tmp &lt;&lt;=1</span><br><span class="line">            res = tmp&amp;high</span><br><span class="line">            tmp = self.mt[i-1]^self.mt[(i+396)%624]</span><br><span class="line">            if tmp &amp; high == high:</span><br><span class="line">                tmp ^= mask</span><br><span class="line">                tmp &lt;&lt;= 1</span><br><span class="line">                tmp |= 1</span><br><span class="line">            else:</span><br><span class="line">                tmp &lt;&lt;=1</span><br><span class="line">            res |= (tmp)&amp;low</span><br><span class="line">            self.mt[i] = res</span><br><span class="line">def example():</span><br><span class="line">    D=MT19937(48)</span><br><span class="line">    print(D.getstate())</span><br><span class="line">    print(D.mt[:5])</span><br><span class="line">    print(D.recover(90324435))</span><br><span class="line">    print(D.extract_number(90324435))</span><br><span class="line">    D.twist()</span><br><span class="line">    print(D.mt[:5])</span><br><span class="line">    D.invtwist()</span><br><span class="line">    print(D.mt[:5])</span><br><span class="line">example()#Main Below</span><br></pre></td></tr></table></figure>

<h2 id="ecc"><a href="#ecc" class="headerlink" title="ecc"></a>ecc</h2><h3 id="p、a、b的值较小的时候："><a href="#p、a、b的值较小的时候：" class="headerlink" title="p、a、b的值较小的时候："></a>p、a、b的值较小的时候：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p =  </span><br><span class="line">a =   </span><br><span class="line">b =   </span><br><span class="line">E = EllipticCurve(GF(p),[a,b])  </span><br><span class="line">P = E(,)</span><br><span class="line">Q = E(,)</span><br><span class="line">k =  discrete_log(Q,P,operation = &#x27;+&#x27;)</span><br><span class="line">print(k)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/crypto/" data-id="cm1ec5c9h0003q0tw1afj97ed" data-title="crypto" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf-crypto/" rel="tag">ctf crypto</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-pwn" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/pwn/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T04:25:58.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/pwn/">pwn</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>首先是一个github上面感觉非常强的<a target="_blank" rel="noopener" href="https://github.com/Dvd848/CTFs/tree/master/2018_35C3_Junior/Wee/">文章</a></p>
<h1 id="gdb的使用"><a href="#gdb的使用" class="headerlink" title="gdb的使用"></a>gdb的使用</h1><p>查看栈内情况</p>
<figure class="highlight plaintext"><figcaption><span>byte $eax</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x /24bx $eax</span><br><span class="line">hexdump byte $esp+0x4 32</span><br></pre></td></tr></table></figure>

<p>使用终端得到汇编代码对应的十六进制</p>
<figure class="highlight plaintext"><figcaption><span>asm -f hex "mov eax, 17"</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">把十六进制翻译成汇编语言（类似ghidra里面的那种）</span><br><span class="line">```pwn disasm &quot;31C9F7E1B00551687373776468632F7061682F2F657489E3CD809391B00331D266BAFF0F42CD809231C0B004B301CD8093CD80&quot;</span><br></pre></td></tr></table></figure>

<p>直接用终端把你想给的数据传过去</p>
<figure class="highlight plaintext"><figcaption><span>"\x31 \x80\n" | nc mercury.picoctf.net 16460</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/pwn/" data-id="cm1ec5c9i0004q0tw339oehwa" data-title="pwn" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf-pwn/" rel="tag">ctf pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-crypto/" rel="tag">ctf crypto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-pwn/" rel="tag">ctf pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-web/" rel="tag">ctf web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ctf-crypto/" style="font-size: 20px;">ctf crypto</a> <a href="/tags/ctf-pwn/" style="font-size: 10px;">ctf pwn</a> <a href="/tags/ctf-web/" style="font-size: 10px;">ctf web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/22/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">BUUCTF刷题记录</a>
          </li>
        
          <li>
            <a href="/2024/09/22/web/">web</a>
          </li>
        
          <li>
            <a href="/2024/09/22/crypto/">crypto</a>
          </li>
        
          <li>
            <a href="/2024/09/22/pwn/">pwn</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Liangyu Chen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>