<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>crypto | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="##RSA算法因数分解网站###e的值很小    import gmpy2    n &#x3D;    e &#x3D;    c &#x3D;    &#x2F;&#x2F;导入n，e，c的值    for i in range(10000):   &#x2F;&#x2F;遍历循环，找到m值        m, t &#x3D; gmpy2.iroot(i*n + c, e)        i">
<meta property="og:type" content="article">
<meta property="og:title" content="crypto">
<meta property="og:url" content="http://example.com/2024/09/22/crypto/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="##RSA算法因数分解网站###e的值很小    import gmpy2    n &#x3D;    e &#x3D;    c &#x3D;    &#x2F;&#x2F;导入n，e，c的值    for i in range(10000):   &#x2F;&#x2F;遍历循环，找到m值        m, t &#x3D; gmpy2.iroot(i*n + c, e)        i">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-09-22T07:18:43.000Z">
<meta property="article:modified_time" content="2024-09-22T08:17:16.037Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="ctf crypto">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-crypto" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/crypto/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:18:43.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      crypto
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>##RSA算法<br><a target="_blank" rel="noopener" href="http://factordb.com/">因数分解网站</a><br>###e的值很小<br>    import gmpy2<br>    n &#x3D;<br>    e &#x3D;<br>    c &#x3D;<br>    &#x2F;&#x2F;导入n，e，c的值<br>    for i in range(10000):   &#x2F;&#x2F;遍历循环，找到m值<br>        m, t &#x3D; gmpy2.iroot(i*n + c, e)<br>        if t:<br>            print(bytearray.fromhex(format(m, ‘x’)).decode()) &#x2F;&#x2F;将十六进制字符串转换为字节后解密<br>            break</p>
<p>###两次加密存在一个相同的质数<br>    from Crypto.Util.number import *<br>    from gmpy2 import powmod as po, gmpy2<br>    import sympy<br>    c1 &#x3D;<br>    c2 &#x3D;<br>    n1 &#x3D;<br>    n2 &#x3D;<br>    e &#x3D;<br>    q &#x3D; gmpy2.gcd(n1, n2)  # 求n1和n2的最大公因数<br>    p1 &#x3D; n1 &#x2F;&#x2F; q<br>    p2 &#x3D; n2 &#x2F;&#x2F; q<br>    fn1 &#x3D; (q - 1) * (p1 - 1)  # 求下面的&amp;n<br>    fn2 &#x3D; (q - 1) * (p2 - 1)  # 求上面的&amp;n<br>    d1 &#x3D; inverse(e, fn1)  # (de)mod((p-1)*(q-1))&#x3D;1  求到第一个解密密钥d1<br>    d2 &#x3D; inverse(e, fn2)  # 求出第二个解密密钥d2<br>    m1 &#x3D; pow(c1, d1, n1)<br>    m2 &#x3D; pow(c2, d2, n2)<br>    print(long_to_bytes(m1))<br>    print(long_to_bytes(m2))</p>
<p>###同一个n用两个e进行加密<br>    from gmpy2 import *<br>    from Crypto.Util.number import *<br>    from gmpy2 import gmpy2<br>    flag1 &#x3D;<br>    flag2 &#x3D;<br>    e1 &#x3D;<br>    e2 &#x3D;<br>    n &#x3D;<br>    def rsa_gong_N_def(e1, e2, c1, c2, n):<br>        e1, e2, c1, c2, n &#x3D; int(e1), int(e2), int(c1), int(c2), int(n)<br>        s &#x3D; gmpy2.gcdext(e1, e2)  # 扩展欧几里得算法  t<em>e1+z</em>e2&#x3D;1,求出t和z<br>        t &#x3D; s[1]<br>        z &#x3D; s[2]<br>        if t &lt; 0:  # 要求c的s次幂，就要先计算c的模反元素c2r，然后求c2r的-s2次幂<br>            t &#x3D; - t<br>            c1 &#x3D; gmpy2.invert(c1, n)  # 求c1的逆元<br>        elif z &lt; 0:<br>            z &#x3D; -z<br>            c2 &#x3D; gmpy2.invert(c2, n)<br>        m &#x3D; (pow(c1, t, n) * pow(c2, z, n)) % n  # (c1^s1*c2^s2)%n&#x3D;m%n&#x3D;m<br>        return m<br>    result &#x3D; rsa_gong_N_def(e1, e2, flag1, flag2, n)<br>    print(long_to_bytes(result))</p>
<p>###有四个质数，其中两个是另外两个的next_prime，已知他们四个数的乘积<br>    import gmpy2<br>    from gmpy2 import *<br>    from Crypto.Util.number import *<br>    import sympy<br>    e &#x3D;<br>    n1 &#x3D;<br>    c1 &#x3D;<br>    def fermat_factorization(n):<br>        factor_list &#x3D; []<br>        get_context().precision &#x3D; 2048	<br>        sqrt_n &#x3D; int(sqrt(n))<br>        c &#x3D; sqrt_n<br>        while True:<br>            c +&#x3D; 1<br>            d_square &#x3D; c*<em>2 - n<br>            if is_square(d_square):<br>                d_square &#x3D; mpz(d_square)<br>                get_context().precision &#x3D; 2048<br>                d &#x3D; int(sqrt(d_square))<br>                factor_list.append([c+d,c-d])<br>            if len(factor_list)&#x3D;&#x3D;2:<br>                break<br>        return factor_list<br>    factor_list &#x3D; fermat_factorization(n1)<br>    [X1,Y1] &#x3D; factor_list[0]	#费马函数分解<br>    [X2,Y2] &#x3D; factor_list[1]<br>    assert X1</em>Y1 &#x3D;&#x3D; n1<br>    assert X2<em>Y2 &#x3D;&#x3D; n1<br>    p1 &#x3D; gcd(X1,X2)<br>    q1 &#x3D; X1 &#x2F;&#x2F; p1		<br>    p2 &#x3D; gcd(Y1,Y2)<br>    q2 &#x3D; Y1 &#x2F;&#x2F; p2<br>    phi1 &#x3D; (p1-1)</em>(q1-1)<em>(p2-1)</em>(q2-1)	#求φ(n)<br>    d1 &#x3D; invert(e,phi1)		#常规RSA解密流程求d<br>    print(long_to_bytes(gmpy2.powmod(c1,d1,n1)),end&#x3D;’’)	##常规RSA解密流程求明文</p>
<p>###dp泄露<br>    from gmpy2 import *<br>    from Crypto.Util.number import *<br>    def rsa(e,n,dp,c):<br>        p&#x3D;0<br>        for i in range(1,e):<br>            if (e<em>dp-1)%i&#x3D;&#x3D;0:<br>                p&#x3D;(e</em>dp-1)&#x2F;&#x2F;i+1<br>                if n%p&#x3D;&#x3D;0:<br>                    break<br>        q&#x3D;n&#x2F;&#x2F;p<br>        d&#x3D;invert(e,(p-1)*(q-1))<br>        print(long_to_bytes(pow(c,d,n)))<br>    if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>        e &#x3D;<br>        n &#x3D;<br>        dp &#x3D;<br>        c &#x3D;<br>        rsa(e,n,dp,c)</p>
<p>###维纳攻击方法（当e的值非常大的时候使用）<br>文件1：Arithmetic.py（后面引用，勿改名）  </p>
<pre><code>def egcd(a,b):
    u, u1 = 1, 0
    v, v1 = 0, 1
    while b:
        q = a // b
        u, u1 = u1, u - q * u1
        v, v1 = v1, v - q * v1
        a, b = b, a - q * b
    return u, v, a
def gcd(a,b):
    a,b=(b,a) if a&lt;b else (a,b)
    while b:
        a,b=b,a%b
    return a
def modInverse(e,n):
    return egcd(e,n)[0]%n
def totient(p,q):
    return (p-1)*(q-1)
def bitlength(x):
    assert x &gt;= 0
    n = 0
    while x &gt; 0:
        n = n+1
        x = x&gt;&gt;1
    return n
def isqrt(n):
    if n &lt; 0:
        raise ValueError(&#39;square root not defined for negative numbers&#39;)
    if n == 0:
        return 0
    a, b = divmod(bitlength(n), 2)
    x = 2**(a+b)
    while True:
        y = (x + n//x)//2
        if y &gt;= x:
            return x
        x = y
def is_perfect_square(n):
    h = n &amp; 0xF; 
    if h &gt; 9:
        return -1 
    if ( h != 2 and h != 3 and h != 5 and h != 6 and h != 7 and h != 8 ):
        t = isqrt(n)
        if t*t == n:
            return t
        else:
            return -1
    return -1
</code></pre>
<p>文件2：ContinuedFractions.py（后面引用，勿改名）  </p>
<pre><code>from typing import List,Tuple
CFListT = List[int]  
CVListT = List[Tuple[int, int]] 
def rational_to_contfrac(x: int, y: int) -&gt; Tuple[CFListT, CVListT]:
    a = x // y
    cflist = [a]
    cvlist = [(a, 1)]
    ppn, ppd = 1, 0 
    pn, pd = a, 1  
    while a * y != x:
        x, y = y, x - a * y
        a = x // y
        cflist.append(a)
        cn, cd = a * pn + ppn, a * pd + ppd
        cvlist.append((cn, cd))
        ppn, ppd = pn, pd
        pn, pd = cn, cd
return cflist, cvlist
</code></pre>
<p>文件3：运行的文件，可随意取名</p>
<pre><code>import gmpy2
from gmpy2 import *
from Crypto.Util.number import *
import sympy
import ContinuedFractions, Arithmetic
def hack_RSA(e,n):
    _, convergents = ContinuedFractions.rational_to_contfrac(e, n)   
    for (k,d) in convergents:
        if k!=0 and (e*d-1)%k == 0:
            phi = (e*d-1)//k
            s = n - phi + 1
            discr = s*s - 4*n
            if(discr&gt;=0):
                t = Arithmetic.is_perfect_square(discr)
                if t!=-1 and (s+t)%2==0:
                    print(&quot;Hacked!&quot;)
                    return d
e=
n=
ct=
d=hack_RSA(e,n)
print(d)
h=pow(  ct, d, n)
print(h)
print(long_to_bytes(h))
</code></pre>
<p>###RSA中的Boneh Durfee Attack攻击方法<br>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/shshss64/article/details/129605810?app_version=6.3.7&code=app_1562916241&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22129605810%22,%22source%22:%222301_79140522%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app">链接</a></p>
<pre><code>import time
debug = True
strict = False
helpful_only = True
dimension_min = 7 # stop removing if lattice reaches that dimension
def helpful_vectors(BB, modulus):
    nothelpful = 0
    for ii in range(BB.dimensions()[0]):
        if BB[ii,ii] &gt;= modulus:
            nothelpful += 1
    print(nothelpful, &quot;/&quot;, BB.dimensions()[0], &quot; vectors are not helpful&quot;)
# display matrix picture with 0 and X
def matrix_overview(BB, bound):
    for ii in range(BB.dimensions()[0]):
        a = (&#39;%02d &#39; % ii)
        for jj in range(BB.dimensions()[1]):
            a += &#39;0&#39; if BB[ii,jj] == 0 else &#39;X&#39;
            if BB.dimensions()[0] &lt; 60:
                a += &#39; &#39;
        if BB[ii, ii] &gt;= bound:
            a += &#39;~&#39;
        print(a)
def remove_unhelpful(BB, monomials, bound, current):
    # end of our recursive function
    if current == -1 or BB.dimensions()[0] &lt;= dimension_min:
        return BB
    # we start by checking from the end
    for ii in range(current, -1, -1):
        # if it is unhelpful:
        if BB[ii, ii] &gt;= bound:
            affected_vectors = 0
            affected_vector_index = 0
            # let&#39;s check if it affects other vectors
            for jj in range(ii + 1, BB.dimensions()[0]):
                if BB[jj, ii] != 0:
                    affected_vectors += 1
                    affected_vector_index = jj
            if affected_vectors == 0:
                print(&quot;* removing unhelpful vector&quot;, ii)
                BB = BB.delete_columns([ii])
                BB = BB.delete_rows([ii])
                monomials.pop(ii)
                BB = remove_unhelpful(BB, monomials, bound, ii-1)
                return BB
            elif affected_vectors == 1:
                affected_deeper = True
                for kk in range(affected_vector_index + 1, BB.dimensions()[0]):
                    if BB[kk, affected_vector_index] != 0:
                        affected_deeper = False
                if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]):
                    print(&quot;* removing unhelpful vectors&quot;, ii, &quot;and&quot;, affected_vector_index)
                    BB = BB.delete_columns([affected_vector_index, ii])
                    BB = BB.delete_rows([affected_vector_index, ii])
                    monomials.pop(affected_vector_index)
                    monomials.pop(ii)
                    BB = remove_unhelpful(BB, monomials, bound, ii-1)
                    return BB
    # nothing happened
    return BB
def boneh_durfee(pol, modulus, mm, tt, XX, YY):
    # substitution (Herrman and May)
    PR.&lt;u, x, y&gt; = PolynomialRing(ZZ)
    Q = PR.quotient(x*y + 1 - u) # u = xy + 1
    polZ = Q(pol).lift()

    UU = XX*YY + 1

    gg = []
    for kk in range(mm + 1):
        for ii in range(mm - kk + 1):
            xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk
            gg.append(xshift)
    gg.sort()

    # x-shifts list of monomials
    monomials = []
    for polynomial in gg:
        for monomial in polynomial.monomials():
            if monomial not in monomials:
                monomials.append(monomial)
    monomials.sort()

    # y-shifts (selected by Herrman and May)
    for jj in range(1, tt + 1):
        for kk in range(floor(mm/tt) * jj, mm + 1):
            yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk)
            yshift = Q(yshift).lift()
            gg.append(yshift) # substitution

    # y-shifts list of monomials
    for jj in range(1, tt + 1):
        for kk in range(floor(mm/tt) * jj, mm + 1):
            monomials.append(u^kk * y^jj)
 
    # construct lattice B
    nn = len(monomials)
    BB = Matrix(ZZ, nn)
    for ii in range(nn):
        BB[ii, 0] = gg[ii](0, 0, 0)
        for jj in range(1, ii + 1):
            if monomials[jj] in gg[ii].monomials():
                BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY)
    if helpful_only:
        BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1)
        nn = BB.dimensions()[0]
        if nn == 0:
            print(&quot;failure&quot;)
            return 0,0
    if debug:
        helpful_vectors(BB, modulus^mm)
    det = BB.det()
    bound = modulus^(mm*nn)
    if det &gt;= bound:
        print(&quot;We do not have det &lt; bound. Solutions might not be found.&quot;)
        print(&quot;Try with highers m and t.&quot;)
        if debug:
            diff = (log(det) - log(bound)) / log(2)
            print(&quot;size det(L) - size e^(m*n) = &quot;, floor(diff))
        if strict:
            return -1, -1
    else:
        print(&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;)
    if debug:
        matrix_overview(BB, modulus^mm)
    if debug:
        print(&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;)

    BB = BB.LLL()

    if debug:
        print(&quot;LLL is done!&quot;)
    if debug:
        print(&quot;looking for independent vectors in the lattice&quot;)
    found_polynomials = False
    
    for pol1_idx in range(nn - 1):
        for pol2_idx in range(pol1_idx + 1, nn):
            # for i and j, create the two polynomials
            PR.&lt;w,z&gt; = PolynomialRing(ZZ)
            pol1 = pol2 = 0
            for jj in range(nn):
                pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY)
                pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY)
            PR.&lt;q&gt; = PolynomialRing(ZZ)
            rr = pol1.resultant(pol2)
            if rr.is_zero() or rr.monomials() == [1]:
                continue
            else:
                print(&quot;found them, using vectors&quot;, pol1_idx, &quot;and&quot;, pol2_idx)
                found_polynomials = True
                break
        if found_polynomials:
            break 
    if not found_polynomials:
        print(&quot;no independant vectors could be found. This should very rarely happen...&quot;)
        return 0, 0 
    rr = rr(q, q)
    soly = rr.roots() 
    if len(soly) == 0:
        print(&quot;Your prediction (delta) is too small&quot;)
        return 0, 0

    soly = soly[0][0]
    ss = pol1(q, soly)
    solx = ss.roots()[0][0]
    return solx, soly

def example(): 
    N =     # the public exponent
    e = 
    c = 
    delta = .28 # this means that d &lt; N^delta
    m = 4 # size of the lattice (bigger the better/slower)
    t = int((1-2*delta) * m)  # optimization from Herrmann and May
    X = 2*floor(N^delta)  # this _might_ be too much
    Y = floor(N^(1/2))    # correct if p, q are ~ same size
    P.&lt;x,y&gt; = PolynomialRing(ZZ)
    A = int((N+1)/2)
    pol = 1 + x * (A + y)
    if debug:
        print(&quot;=== checking values ===&quot;)
        print(&quot;* delta:&quot;, delta)
        print(&quot;* delta &lt; 0.292&quot;, delta &lt; 0.292)
        print(&quot;* size of e:&quot;, int(log(e)/log(2)))
        print(&quot;* size of N:&quot;, int(log(N)/log(2)))
        print(&quot;* m:&quot;, m, &quot;, t:&quot;, t)

    if debug:
        print(&quot;=== running algorithm ===&quot;)
        start_time = time.time()

    solx, soly = boneh_durfee(pol, e, m, t, X, Y)
 
    if solx &gt; 0:
        print(&quot;=== solution found ===&quot;)
        if False:
            print(&quot;x:&quot;, solx)
            print(&quot;y:&quot;, soly)
 
        d = int(pol(solx, soly) / e)
        print(&quot;private key found:&quot;, d)
        print(&quot;plaintext:&quot;, pow(c, d, N))
    else:
        print(&quot;=== no solution was found ===&quot;)

    if debug:
        print(&quot;=== %s seconds ===&quot; % (time.time() - start_time))

if __name__ == &quot;__main__&quot;:
    example()
</code></pre>
<p>##prng算法（利用random.getrandbits函数只能产生固定数量的随机数）（梅森旋转算法）<br>###向后恢复随机数<br>    from hashlib import sha256<br>    from randcrack import RandCrack &#x2F;&#x2F;该库专门用来梅森旋转算法的破解<br>    t&#x3D;[]<br>    rc &#x3D; RandCrack()<br>    for i in t:<br>        rc.submit(i)<br>    flag1 &#x3D; rc.predict_getrandbits(32)<br>    flag2 &#x3D; rc.predict_getrandbits(32)<br>    print(sha256((str(flag1)+str(flag2)).encode()).hexdigest())</p>
<p>利用别人写的脚本    </p>
<pre><code>from random import Random
def inverse_right(res,shift,bits=32):
    tmp=res
    for i in range(bits//shift):
        tmp=res^tmp&gt;&gt;shift
    return tmp
def inverse_left_mask(res,shift,mask,bits=32):
    tmp=res
    for i in range(bits//shift):
        tmp=res^tmp&lt;&lt;shift&amp;mask
    return tmp
def inv_extract_number(y):
    y=inverse_right(y,18)
    y=inverse_left_mask(y,15,4022730752)
    y=inverse_left_mask(y,7,2636928640)
    y=inverse_right(y,11)
    return y&amp;0xffffffff
def recover_mt(record):
    state=[inv_extract_number(i) for i in record][:624]
    gen=Random()
    gen.setstate((3,tuple(state+[0]),None))
    return gen
ss=[]
mt=recover_mt(ss)
for i in range(624):
    mt.getrandbits(32)
print(mt.getrandbits(32))
</code></pre>
<p>###向前恢复随机数<br>首先下载库  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install extend_mt19937_predictor</span><br></pre></td></tr></table></figure>
<p>然后使用代码  </p>
<pre><code>from extend_mt19937_predictor import ExtendMT19937Predictor
numbers = []
predictor = ExtendMT19937Predictor()

for i in range(628):
    predictor.setrandbits(numbers[i], 32)
result = [predictor.backtrack_getrandbits(32) for _ in range(625)]
</code></pre>
<p>梅森旋转算法（亲测有效）  </p>
<pre><code>from Crypto.Util.number import *
from hashlib import md5
import random
def _int32(x):
    return int(0xFFFFFFFF &amp; x)
class MT19937:
    def __init__(self, seed=0):
        self.mt = [0] * 624
        self.mt[0] = seed
        self.mti = 0
        for i in range(1, 624):
            self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] &gt;&gt; 30) + i)
    def getstate(self,op=False):
        if self.mti == 0 and op==False:
            self.twist()
        y = self.mt[self.mti]
        y = y ^ y &gt;&gt; 11
        y = y ^ y &lt;&lt; 7 &amp; 2636928640
        y = y ^ y &lt;&lt; 15 &amp; 4022730752
        y = y ^ y &gt;&gt; 18
        self.mti = (self.mti + 1) % 624
        return _int32(y)
    def twist(self):
        for i in range(0, 624):
            y = _int32((self.mt[i] &amp; 0x80000000) + (self.mt[(i + 1) % 624] &amp; 0x7fffffff))
        self.mt[i] = (y &gt;&gt; 1) ^ self.mt[(i + 397) % 624]
            if y % 2 != 0:
                self.mt[i] = self.mt[i] ^ 0x9908b0df
    def inverse_right(self,res, shift, mask=0xffffffff, bits=32):
        tmp = res
        for i in range(bits // shift):
            tmp = res ^ tmp &gt;&gt; shift &amp; mask
        return tmp
    def inverse_left(self,res, shift, mask=0xffffffff, bits=32):
        tmp = res
        for i in range(bits // shift):
            tmp = res ^ tmp &lt;&lt; shift &amp; mask
        return tmp
    def extract_number(self,y):
        y = y ^ y &gt;&gt; 11
        y = y ^ y &lt;&lt; 7 &amp; 2636928640
        y = y ^ y &lt;&lt; 15 &amp; 4022730752
        y = y ^ y &gt;&gt; 18
        return y&amp;0xffffffff
    def recover(self,y):
        y = self.inverse_right(y,18)
        y = self.inverse_left(y,15,4022730752)
        y = self.inverse_left(y,7,2636928640)
        y = self.inverse_right(y,11)
        return y&amp;0xffffffff
    def setstate(self,s):
        if(len(s)!=624):
            raise ValueError(&quot;The length of prediction must be 624!&quot;)
        for i in range(624):
            self.mt[i]=self.recover(s[i])
        #self.mt=s
        self.mti=0
    def predict(self,s):
        self.setstate(s)
        self.twist()
        return self.getstate(True)
    def invtwist(self):
        high = 0x80000000
        low = 0x7fffffff
        mask = 0x9908b0df
        for i in range(623,-1,-1):
            tmp = self.mt[i]^self.mt[(i+397)%624]
            if tmp &amp; high == high:
                tmp ^= mask
                tmp &lt;&lt;= 1
                tmp |= 1
            else:
                tmp &lt;&lt;=1
            res = tmp&amp;high
            tmp = self.mt[i-1]^self.mt[(i+396)%624]
            if tmp &amp; high == high:
                tmp ^= mask
                tmp &lt;&lt;= 1
                tmp |= 1
            else:
                tmp &lt;&lt;=1
            res |= (tmp)&amp;low
            self.mt[i] = res
def example():
    D=MT19937(48)
    print(D.getstate())
    print(D.mt[:5])
    print(D.recover(90324435))
    print(D.extract_number(90324435))
    D.twist()
    print(D.mt[:5])
    D.invtwist()
    print(D.mt[:5])
example()#Main Below
</code></pre>
<p>##ecc<br>###p、a、b的值较小的时候：</p>
<pre><code>p =  
a =   
b =   
E = EllipticCurve(GF(p),[a,b])  
P = E(,)
Q = E(,)
k =  discrete_log(Q,P,operation = &#39;+&#39;)
print(k)
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/crypto/" data-id="cm1db3jyh0000tktwgd4t3umj" data-title="crypto" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf-crypto/" rel="tag">ctf crypto</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/09/22/web/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          web
        
      </div>
    </a>
  
  
    <a href="/2024/09/22/pwn/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">pwn</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-crypto/" rel="tag">ctf crypto</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-pwn/" rel="tag">ctf pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf-web/" rel="tag">ctf web</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ctf-crypto/" style="font-size: 20px;">ctf crypto</a> <a href="/tags/ctf-pwn/" style="font-size: 10px;">ctf pwn</a> <a href="/tags/ctf-web/" style="font-size: 10px;">ctf web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/22/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">BUUCTF刷题记录</a>
          </li>
        
          <li>
            <a href="/2024/09/22/web/">web</a>
          </li>
        
          <li>
            <a href="/2024/09/22/crypto/">crypto</a>
          </li>
        
          <li>
            <a href="/2024/09/22/pwn/">pwn</a>
          </li>
        
          <li>
            <a href="/2024/09/22/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>